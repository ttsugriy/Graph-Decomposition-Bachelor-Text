\documentclass[12pt]{article}
\usepackage[cp866nav]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{bezier}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphics}

\voffset=0in
\hoffset=-0.1in
\parskip=0.01in
\textwidth=6.5in
\textheight=9.0in
\oddsidemargin=6mm
\evensidemargin=-6mm
\topmargin=-10mm


\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лема}
\newtheorem{corollary}{Наслўдок}
\newtheorem{definition}{Означення}
\newtheorem{utver}{Твердження}

\def\refname{Лўтература}

\begin{document}

\begin{center}
    {\bf МЎНЎСТЕРСТВО ОСВЎТИ Ў НАУКИ УКРА°НИ}

\vspace{1.5cm}

     {\bf КИ°ВСЬКИЙ НАЦЎОНАЛЬНИЙ УНЎВЕРСИТЕТ\\
          ўменў ТАРАСА ШЕВЧЕНКА}

\vspace{1cm}

                   {\bf ФАКУЛЬТЕТ КЎБЕРНЕТИКИ}
\end{center}

\vspace{6cm}

\newcommand{\ttl}[3]{%
\vspace*{-1.0cm}
\begin{center}
{\huge #1}\\[4mm]
{\Large\sl #2}
\end{center}
%\def\thefootnote{}%
%\footnote{#3}
}
\def\f{$\vphantom{gl}$}
\ttl{{\Large ПРОБЛЕМИ РОЗРОБКИ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ\\
     Формалўзацўя, модель, алгоритм, програма, верифўкацўя}}
{Кривий С. Л.}

\vspace{8cm}

\begin{center}
    {\bf КИ°В -- 2008}
\end{center}

{\scriptsize
\tableofcontents
}
\sloppy

\newpage

\begin{abstract}
В даному курсў розглядаються проблеми,  пов'язанў з процесом
розробки та  обгрунтування  програмного   забезпечення   сучасних
комп'ютерних систем.  Зокрема, головна увага зосереджена на
проблемў верифўкацў∙ програмних систем.

\end{abstract}

\section{ВСТУП}
\ \ \ \ Розвиток комп'ютерно∙ технўки та ∙∙ проникнення в усў сфери
людсько∙ дўяльностў спричинили великий ўнтерес до рўзних  областей
комп'ютерно∙ науки.  Однўїю з таких областей ї процес розробки та
обгрунтування програм та програмних систем ў  комплексўв.
Розглядаючи цю  проблему  детальнўше,  можна  побачити,  що процес
створення технўчного забезпечення суттїво опережаї  процес
створення програмного забезпечення.

     В ўдеалў  процес  створення  програми  мав би виглядати так:
розробник програми формулюї свою задачу у виглядў формули  деяко∙
формально∙ логўчно∙ системи (мови) ў за цўїю формулою уже в
автоматичному режимў будуїться програма.

 На жаль,  до досягнення цього ўдеалу ще досить  далеко,  оскўльки
процес {\bf ``початкова задача -- готова програма''} та його реалўзацўя
вўдноситься до так званих проблем, якў важко формалўзуються. Далў
разом з Разом з цўїю проблемою в даному курсў будуть розглядатися
проблема верифўкацў∙ програмних систем та роль абстрактних типўв
даних  в процесў побудови алгоритму та методи потокового аналўзу
програм.

Процес побудови комп'ютерно∙ програми для  розв'язання  яко∙-небудь
практично∙ задачў складаїться з декўлькох етапўв:

     -- формалўзацўя ў розробка технўчного завдання на дану задачу;

     -- розробка алгоритма розв'язання задачў;

     -- аналўз складностў алгоритму;

     -- створення програми;

     -- вўдладка програми;

     -- тестування та верифўкацўя програми;

     -- розв'язання поставлено∙ задачў шляхом виконання програми.

     Зрозумўло, що коли вўдомо,  що дана задача маї  розв'язання,
то половина справи зроблена. Але, на жаль, бўльшўсть реальних
задач, якў зустрўчаються в практицў, не мають чўткого ў однозначного
опису. Деякў задачў, такў як ``врятувати красою свўт'' чи ``знайти
рецепт вўчно∙ молодостў'',  взагалў неможливо  сформулювати  в
термўнах,  якў допускають комп'ютерне розв'язання.  Навўть у тому
випадку коли вўдомо,  що задача маї комп'ютерне  розв'язання,  як
правило,  для  ∙∙  формального опису потрўбна величезна кўлькўсть
рўзного роду параметрўв.  Часто тўльки в ходў виконання
експериментўв можна знайти границў ∙х використання та змўни.

Якщо деякў деталў сформульовано∙ задачў можна виразити в термўнах
яко∙-небудь формально∙ моделў,  то це необхўдно зробити, оскўльки
в рамках цўї∙ моделў можна вияснити, чи ўснують методи ў алгоритми
розв'язання дано∙ задачў.  Навўть коли такў методи ў алгоритми не
ўснують, то всерўвно засоби ў властивостў формально∙ моделў допомагають
в побудовў ``пўдходящого'' розв'язання поставлено∙ задачў.
Основним засобом  при такому пўдходў вўдўграють формальнў методи.

\subsection{Формальнў методи}
Комп'ютернў системи подўляються на два класи: клас функцўональних
систем ў клас реактивних систем.

     Перший клас  характеризуїться тим,  що цў системи працюють в
скўнченному часў ў якщо цей час перевищуї деякў розумнў  границў,
то  це квалўфўкуїться як помилка в такўй системў.  До цього класу
вўдносяться програми обчислення значень  функцўй,  рядўв,  розв'язання
рўвнянь тощо.

     Другий клас систем характеризуїться тим, що такў системи
повиннў працювати потенцўально некўнченний час.  Такў системи пўд
час роботи  реагують на зовнўшнў ў внутрўшнў подразники (звўдси ў
йде ∙х назва). На вўдмўну вўд функцўональних систем, реактивнў
системи вважаються неправильними, якщо вони закўнчують свою роботу
в скўнченному часў.  До такого типу систем вўдносяться операцўйнў
системи, системи пўдготовки та редакцў∙ текстўв ў т.п.

     Коли мова  заходить  про обгрунтування правильностў
функцўональних ў реактивних систем, то цў методи рўзнў. Розглянемо
коротко цў методи.

\subsubsection{Функцўональнў системи та методи ∙х обгрунтування}
\ \ \ \ Як зазначалося вище,  побудова ўнтелектуального
ўнтерпретатора, який  за специфўкацўїю будував би правильну
програму, ї поки що недосяжною мрўїю. Цўй мрў∙ вже понад 40 рокўв.
Не дивлячись  на те що проблема виявилася досить складною,  ўснуї
певний оптимўзм в ∙∙ розв'язаннў. Цей оптимўзм пов'язаний перш за
все з такими фактами:

     -- {\em Ї суттївў досягнення в технологўях автоматизованого пошуку
доведеннь теорем в областў верифўкацў∙.}

     -- {\em Ї значнў успўхи в областў верифўкацў∙  технўчного
забезпечення шляхом   використання  методу  перевўрки  на  моделў
(model checking).}

     -- {\em Отримали  додатковий розвиток методи аналўзу програм,  що
грунтуються на  абстрактних ўнтерпретацўях ў технологўях компўляцў∙.}

     -- {\em Наявна висока зрўлўсть програмних ўнженерўв,  якў
знаходяться на рўвнў продукування промислових розмўрўв програмного
забезпечення.}

     Деякў кроки в перелўчених областях автоматизованў, але деякў
з них потребують взаїмодў∙ з користувачем.  Основною областю, яка
потребуї дўалогу  з  користувачем,  ї область антоцў∙ програм.  В
цьому випадку користувач анотуї свою програму в рўзних  контрольних
точках певними твердженнями. Сенс цих анотацўй полягаї в тому, що
твердження вўдповўдних анотацўй повиннў виконуватися всякий  раз,
коли процес обчислень досягаї дано∙ контрольно∙ точки програми, з
якою асоцўйована антотацўя.

     Анотацў∙ можуть використовуватися в рўзних режимах ў  рўзними
способами. Основними режимами ї такў:

     -- {\bf  Глобальне  тестування.} Пўд час тестування програми
на рўзних вхўдних  даних  перевўряїться  виконуванўсть  тверджень
всўх анотацўй.

     -- {\bf  Верифўкацўя пўд час виконання.} Внутрўшнў твердження,
якў перевўряються пўд час компўляцў∙,  сигналўзують  про  помилки
якщо вони не виконуються. Часом оптимўзацўйнў перетворення програми
можуть усунути деякў з цих перевўрок пўд час виконання.


     -- {\bf  Статична верифўкацўя.} Цього типу верифўкацўя
називаїться формальною ў сенс ∙∙ полягаї в  тому,  що  твердження,
якў описують  правильнўсть  програми,  виконуються всякий раз при
кожному виконаннў цўї∙ програми.

     Зў всього сказаного випливають такў проблеми:

{\bf ПРОБЛЕМА 1.  Розвинути бўльш багату теорўю анотацў∙ програм,
яка включаї рекурсивнў процедури та функцўональнў програми.

ПРОБЛЕМА 2.  Розвивати мову анотацўй вўд мови простих тверджень до
мови бўльш загальних темпоральних тверджень.}

     Для програм з простими змўнними вўдомў двў формальнў системи,
якў використовуються  в  цўлях верифўкацў∙ -- це системи Флойда ў
Хоара. Про цў системи буде йти розмова пўзнўше.


\subsubsection{Реактивнў системи та методи ∙х обгрунтування}
\ \ \ \ Цў методи класифўкуються з точки зору ∙х використання в  системах
проектування ў верифўкацў∙. Основними з них ї наступнў:

     -- написання формальних специфўкацўй;

     -- доведення властивостей специфўкацўй;

     -- встановлення  виконуваностў даних специфўкацўй (ўснування
        ўнтерпретацў∙) ;

     -- верифўкацўя специфўкацўй вўдносно даних ўнтерпретацўй.

        Розглянемо детальнўше цў пўдходи ў встановимо границў  ∙х
можливостей в процесў проектування.

     {\bf Написання  формальних  специфўкацўй}.  Формальнў методи
використовуються для обгрунтування сенсу  математичних  об'їктўв.
Справа в тому, що технўчнў пристро∙ не ї математичними об'їктами,
а ї фўзичними об'їктами реального свўту ў  тому  ∙х  специфўкацў∙
задаються неформально. Отже, необхўдно будувати математичнў моделў
таких систем ў специфўкувати ∙х властивостў  шляхом  використання
певно∙ формально∙ математично∙ мови. Крўм того, ще одна труднўсть
полягаї в тому,  що модель та ∙∙ властивостў не несуть нўяко∙
ўнформацў∙ про  те,  який  формальний метод слўд використовувати.
Це пов'язано з тим,  що сама специфўкацўя може давати лише
формальний опис системи та ∙∙ формальнў властивостў.

     В зв'язку  з цим появляються мови програмування з формальною
семантикою, поданою у виглядў математично∙ моделў, якў можуть
використовуватися для застосування формальних методўв.  Саме тому
програмўсти ў розробники технўчних пристро∙в завжди мають  справу
з формальними моделями, навўть тодў, коли не передбачаїться
використання формальних методўв в процесў проектування.

     {\bf Доведення властивостей специфўкацўй}. Як зазначалося вище,
специфўкацў∙ часто  задаються неформально ў вони повиннў
переформульовуватися в термўнах деяко∙ формально∙ мови.  Це необхўдно
робити для  того,  щоб переконатися в тому,  що данў специфўкацў∙
описують те,  що передбачалося.  Зокрема, важливим фактом ї
встановлення виконуваностў дано∙ специфўкацў∙, тобто належить
встановити ўсування принаймнў однўї∙ ўнтерпретацў∙ за яко∙  дана
специфўкацўя виконуїться.  Наприклад, специфўкацўя
\begin{center}
$a^{(0)} \land  a^{(1)}  \land  \forall  t  \  a^{(t+1)}  =  \neg
a^{(t)}$,
\end{center}
яка виражаї той факт,  що $a$ приймаї значення 1 (правда) в першў
два моменти часу,  а потўм $a$ приймаї значення 0 (хибнўсть).
Коректною буде також специфўкацўя
\begin{center}
$a^{(0)} \land a^{(1)} \land  \neg  a^{(2)}  \land  \forall  t  \
a^{(t+3)} = \neg a^{(t+2)}$.
\end{center}
Часто досить корисним ї встановлення еквўвалентностў рўзних
специфўкацўй, що дозволяї глибше зрозумўти завдання ў процес його
виконання. Навўть коли специфўкацўя не верифўкуїться, бўльш пўзнў
виконання цього кроку ведуть до бўльш глибокого розумўння проблеми
ў ∙∙ структуризацў∙. Це даї змогу за допомогою формальних методўв
шукати помилки на етапў специфўкацў∙.

     {\bf Отримання реалўзацў∙ ўз специфўкацўй}.  Якщо специфўкацўя
знайдена ў вўдображаї те,  що потрўбно, то вона може стати корисним
засособом автоматичного отримання реалўзацў∙ системи. Такого типу
ўдея стала  домўнуючою  в  мовах програмування п'ятого поколўння,
наприклад в мовў програмування ПРОЛОГ, де специфўкацўя ў ∙∙
впровадження стоять близько одна до друго∙.

     Але часто  специфўкацў∙  носять декларативний характер ў тому
не ї конструктивними.  Це означаї,  що такў  специфўкацў∙  тўльки
описують {\bf  що}  система повинна виконувати,  а не те {\bf як}
цього можна досягти.  В такому випадку неможливо виходячи лише ўз
декларативних специфўкацўй побудувати коректнў програми, оскўльки
ця проблема ї нерозв'язною для комп'ютера. Не уявляїться можливим
одержання алгоритму  в який-небудь абстрактний спосўб при ўгноруваннў
деталей його реалўзацў∙.  В цьому випадку використовуються пўдходящў
засоби для конструювання бўльш деталўзованих систем реалўзацў∙.
Наприклад, алгоритм може бути написаний на мовў програмування
високого рўвня  ў компўлятор можна використати для трансляцў∙
алгоритму до деяко∙ мови машинного рўвня,  яка може бути виконана
на мўкропроцесорў.

     {\bf Верифўкацўя специфўкацўй вўдносно даних ўнтерпретацўй}.
Застосування формальних методўв даї можливўсть формальним способом
тестувати несуперечнўсть  (суперечнўсть) ў виконуванўсть специфўкацўй,
побудованих вручну на всўх кроках проектування.  Це необхўдно робити
в зв'язку  з  тим,  що кожне уточнення деталей проекту майбутньо∙
системи повинне зберўгати правильнўсть специфўкацўй.  Такого типу
процес називаїться верифўкацўїю даних специфўкацўй.

     Ўснуї два види формально∙ верифўкацў∙.  Перший з них полягаї
в тому,  що описуїться формальна модель системи $F_{imp}$  та  ∙∙
специфўкацўя $F_{spec}$  формулами деяко∙ формально∙ логўчно∙ мови.
А потўм розглядаїться ∙х еквўвалентнўсть або логўчне  слўдування,
тобто $F_{imp}   \to   F_{spec}$   або  $F_{imp}  \leftrightarrow
F_{spec}$. Цей метод грунтуїться на методах ў системах  автоматизованого
пошуку доведення  теорем  (пруверах)  в формальних логўчних мовах
(логўках). Недолўком такого методу ї те,  що специфўкацўя тўльки
частково описуї поведўнку системи.

     Другим видом формально∙ верифўкацў∙ ї метод перевўрки на моделў
(model checking). В цьому пўдходў до верифўкацў∙ система подаїться
у виглядў логўчно∙ моделў (ўнтерпретацў∙),  на якўй перевўряїться
виконуванўсть специфўкацў∙.

     Далў будуть розглядатися обидва пўдходи до верифўкацў∙ систем
та ∙х специфўкацўй.

\input{modal.tex}
\newpage
\input{potok1.tex}
\newpage


\section{Мова рўвностей ў лўнўйних нерўвностей}
\subsection{Вўльнў групи}
\ \ \ \ В цьому пўдроздўлў розглядаються $U-Y$-програми над вўльними
даних, якў ї вўльними групами ў для яких алгоритми МВА ў МНА
породжують в кожному станў множини  ўнварўантўв, якў ї монотонними
гратками. Ўншими словами, функцўя $ef$ для цих алгебр ї монотонною
а не дистрибутивною.


\subsubsection{Нўльсенўвськў перетворення ў базиси для вўльних груп}
\ \ \ \ Нехай $T_D(R)$ вўльна група ў $P = (p_1,\ldots, p_m)$ --
деяка послўдовнўсть  нескорочуваних слўв ўз $T_D(R)$.  Нагадаїмо,
що сумарною довжиною послўдовностў $P$ називаїться величина
\begin{center}
        $L(P) = \sum\limits_{i=1}^m l(p_i), \ p_i \in P$,
\end{center}
де $l(p_i)$ -- довжина слова $p_i, \ i = 1,2,\ldots,m$.

Послўдовнўсть $P$ називаїться системою твўрних пўдгрупи $H$ групи
$T_D(R)$, якщо слова, що складають послўдовнўсть $P$,
породжують цю пўдгрупу. Якщо $P$ система твўрних пўдгрупи $H$, то
ця пўдгрупа визначаїться системою $P$ однозначно ў буде позначатися
через $G_P(R)$. Систему $P$ твўрних групи $Н$ будемо називати
{\bf базисом (системою вўльних твўрних)} цўї∙ групи, якщо кожне слово
ўз $H$ їдиним чином представляїться через твўрнў системи $P$. Ўншими
словами, рўвнўсть
\begin{center}
$p_{i_1}^{a_1}\ldots p_{i_k}^{a_k} = p_{j_1}^{b_1}\ldots p_{j_l}^{b_l}$,
\end{center}
можлива тодў ў тўльки тодў, коли $k = l, i_1=j_1,\ldots, i_k=j_l,
\ a_1 = b_1,\ldots, a_k = b_l$.

Найбўльш вўдомими базисами пўдгруп вўльних груп  ї  {\bf  нўльсенўвськў
системи твўрних}.

Нехай $p, q$ -- деякў слова в алфавўтў $R \cup R^{-1}$.  Слово $q$
називаїться {\bf початком (кўнцем) слова}  $p$,  якщо  маї  мўсце
розклад $p = qp_1 \ (p = p_1q)$, где $p_1$ -- пўдходяще непусте слово.

Нехай задана послўдовнўсть слўв $P = (p_1,\ldots, p_m)$.  Слово
$q$ назвемо ўзольованим вўдносно послўдовностў $P$, якщо ўснуї не
бўльше, нўж одне слово $p_i \ (i=1,2,\ldots, m)$ таке, що $q$
ї початком (кўнцем) або для $p_i$ або для $p_i^{-1}$. Старшим початком
слова $p$ назвемо такий початок $q$ цього слова,  довжина якого
задовольняї нерўвнўсть $1/2 l(p) < l(q) \leq 1/2 l(p)+1$. Аналогўчно
визначаїться старший  кўнець слова.  Для слўв парно∙ довжини природним
чином визначаїться ∙х лўва ў права половини.

Послўдовнўсть $P  = (p_1,p_2,\ldots, p_m)$ непустих нескорочуваних
слўв називаїться {\bf нўльсенўвською},  якщо виконуїться наступнў
двў умови:

     -- {\em старшў початки ў кўнцў всўх слўв ўз $P$ ўзольованў};

     -- {\em для кожного слова ўз $P$ парно∙ довжини принаймнў одна
з його половин -- лўва або права -- ўзольованў.}

Побудова нўльсенўвсько∙ множини твўрних виконуїться за допомогою
елементарних нўльсенўвських перетворень. Цў перетворення визначаються
таким чином.

Нехай $P = (p_1, p_2,\ldots, p_m)$ -- деяка $m$-ка непустих
нескорочуваних слўв в алфавўтў $R \cup R^{-1}$. {\bf
Елементарними нўльсенўвськими перетвореннями} множини $P$ називаються:

а) перестановка  слўв $m$-ки ў замўна любого слова з $P$ на обернене,
тобто $m$-ку $(p_1, p_2,\ldots, p_m)$   можна   замўнити $m$-кою
\begin{center}
      $(p_{i_1}^{e_1},p_{i_2}^{e_2},\ldots, p_{i_m}^{e_m}$,
\end{center}
где $e_i = \pm 1,$ a $(i_1,\ldots,  i_m)$ --  деяка  перестановка
елементўв $(1,2,\ldots, m)$;

б) замўна  слова $p_i$  на результат приведення одного ўз добуткўв
$p_kp_j^n,  p_j^np_k,  p_j^np_kp_j^{-n}$,  де  $k, j$ --
фўксованў, $k, j = 1,\ldots, m, n = \pm 1$, при якўй решта $p_i$
залишаються незмўнними.

Очевидно, що коли до деяко∙ послўдовностў  слўв $P$ застосувати
елементарне нўльсенўвське перетворення,  то отримана послўдовнўсть
породжуї ту саму пўдгрупу, що ў початкова.

Ефективний алгоритм побудови нўльсенўвсько∙ системи  твўрних
описаний в роботў \cite{74}, а його реалўзацўя в \cite{75}.
Скористаїмося даною версўїю алгоритма.

Позначимо через $P_0$ початкову систему твўрних, через $CON(P)$
--  множину всўх наслўдкўв, отриманих ўз системи $P$ однократним
застосуванням нўльсенўвських перетворень, через ПЎ($P$) -- предикат,
ўстинний тодў ў тўльки тодў,  коли правў (або лўвў) половини
всўх слўв парно∙ довжини ўз системи $P$ ўзольованў,  через $P[i]$
- $i$-й елемент послўдовностў $P$,  через $L(P[i])$ -- довжину ∙∙
$i$-го елемента.
\begin{center}
                      АЛГОРИТМ НЎЛ $(P_0$).
\end{center}

{\bf початок}

\ \ \ \ $P := P_0$.

\ \  \  ЎС:  if  ($\exists  P'  \in  CON(P)) (L(P) > L(P'))$ then
           ($P:=P'$; goto ЎС).

\ \ \ \ if ПЎ($P$) then STOP.

\ \ \ \ упорядкувати слова $P$ за зростанням ∙х довжини ў  помўстити
        пустў слова в кўнець послўдовностў $P$.

\ \ \ \ for i = 2,..., m do

\ \ \ \ \ \ if L(P[i]) = 0 then goto ЎС.

\ \ \ \ \ \ ОБЕРНЕНИЙ := 0.

\ \ \ \ ПОВТ: for j = 1,...,i-1 do

\ \ \ \ \ \ if $L(P[i]) > L(P[i]P^{-1}[j])$   then
($P[i]:=P[i]P^{-1}[j]$. goto ЎС).

\ \  \   \   \   \   if   $L(P[i])   =   L(P[i]P^{-1}[j])$   then
$P[i]:=P[i]P^{-1}[j].$

\ \ \ \ od

\ \ \ \ \ \ \ if ОБЕРНЕНИЙ=О то (ОБЕРНЕНИЙ:=1. $P[i]:=P^{-1}[i]$. goto ПОВТ).

\ \ \ \ \ \ \ if L(P[i]) парне then

\ \ \ \ \ \ \ \ for j = 1,...,i-1 do

\ \  \ \ \ \ \ \ \ \ if L(P[j]) > L(P[i]P[j]) то (P[j]:=P[i]P[j]. goto ЎС).

\ \ \ \ \ \ \ \ \ \ if L(P[j]) = L(P[i]P[j]) то P[j]:=P[i]P[j].

\ \ \ \ \ \ \ \ od

\ \ \ \ od.

\ \ \ \ goto ЎС.

{\bf кўнець}


\begin{lemma}
Часова складнўсть    алгоритма   НЎЛ   пропорцўональна   величинў
$|P_0|(L(P_0))^2$.
\end{lemma}

{\em Доведення}. Перш за все зазначимо, що пўсля проходження
мўтки ЎС, за винятком можливо, останнього, вўдбуваїться зменшення
сумарно∙ довжини слўв  послўдовностў $P$. Отже, зовнўшнўй цикл,
який проходить через мўтку ЎС повторюїться не бўльше $L(P_0)$ разўв.

Виконання оператора, позначеного мўткою ЎС, вимагаї порядка
$|P|^2$ порўвнянь слўв,  або з урахуванням ∙х довжини,  $|P|L(P)$
порўвнянь символўв.  Час, необхўдний на упорядкування слўв послўдовностў
$P$, очевидно,  не перевищуї $|P|L(P)$.  Далў,  вкладенў цикли по
$i$ ў $j$ вимагають порядка $|P|$ конкатенацўй слўв або, приймаючи
до уваги  ∙х довжини ў необхўднўсть приведення результатўв конкатенацў∙,
порядка $|P|L(P)$ символьних перетворень.

Таким чином,  верхня оцўнка загального числа символьних  перетворень,
якў виконуються алгоритмом НЎЛ з точнўстю до константи дорўвнюї
$|P|(L(P_0))^2$. $\blacksquare$


\subsection{Розв'язок задачў про спўввўдношення}
\ \ \ \ Нехай
\begin{center}
         $r_1 :=  r_{i_1}^{a_{11}}\ldots r_{i_{k_1}}^{a_{1k}}$

         $r_2 :=  r_{i_1}^{a_{21}}\ldots r_{i_{k_2}}^{a_{2k}}$

         ..............................

         $r_m :=  r_{i_1}^{a_{m1}}\ldots r_{i_{k_m}}^{a_{mk}}$
\end{center}
-- оператори   лўнўйно∙   ланки  програми  пўсля  композицў∙,  де
$a_{i_j}$ цўлў числа, $i, m = |R|, \ j = 1,2,\ldots, m.$

     Спўввўдошення лўнўйно∙ ланки в цьому випадку зводятся до
залежностей типу
\begin{equation}\label{5.1.2}
          r_{j_1}^{a_1}\ldots r_{j_l}^{a_l},
\end{equation}
де $e$ --  пусте слово -- одиниця групи $T_D(R)$,  $a_k$ -- целў
числа. Позначимо через $H$ -- пўдгрупу групи $T_D(R)$, елементами
яко∙ ї слова виду (\ref{5.1.2}).  Очевидно,  що $H$ -- нормальна
пўдгрупа групи $T_D(R)$.

Нехай $P_{LT} = (r_1,\ldots, r_m)$ ў $P_{RT} = (p_1,\ldots, p_m)$
двў  послўдовностў  слўв,  якў стоять вўдповўдно в лўвўй ў правўй
частинах операторўв присвоювання вищенаведено∙ послўдовностў. Так
як  група  $G_P(R)$  вўльна,  то ўснуї послўдовнўсть елементарних
нўльсенўвських перетворень $w_1,\ldots, w_n$, в результатў засто-
сування  яких до системи $P_{RT}$ отримуїмо нўльсенўвську систему
твўрних групи $G_P(R)$ -- $(p_1,\ldots,  p_k,e,\ldots, e).$ Розглянемо
систему
\begin{center}
$w_nw_{n-1}\ldots w_1(P_{LT}) = (p_1,\ldots, p_k, p_{k+1},\ldots, p_m)$
\end{center}
ў позначимо через $P$ множину слўв  $(p_{k+1},\ldots,  p_m)$.  Цў
слова мають вигляд (\ref{5.1.2}) ў тому $\{P\} = H$. Нехай $H(P)$
-- нормальна пўдгрупа, породжена словами множини $P$. Маї мўсце
\begin{lemma}\label{l5.1.2}
                            H = H(P).
\end{lemma}

    {\em Доведення}. Нехай $u$ -- довўльне слово ўз $H$.  Сумўжнў
класи групи     $G_{P_{RT}}(R)/H(P)$     породжуїться     словами
$(p_1,p_2,\ldots, p_k)$.

Отже, $u = e = r_{j_1}^{a_1} r_{j_2}^{a_2}\ldots r_{j_l}^{a_l} =
(p_{i_1}^{g_1}\ldots   p_{i_t}^{g_t})(p_{i_{t+1}}^{g_{t+1}}\ldots
p_{i_q}^{g_q})$, где  $p_{i_{t+1}}^{g_{t+1}}\ldots  p_{i_q}^{g_q}
\in H(P)$. Поскольку $p_{i_1},\ldots, p_{i_t}$ вўльнў твўрнў
$GP_{RT}(R)/H(P)$, то      слово  $p_{i_{t+1}}^{g_{t+1}}\ldots
p_{i_q}^{g_q}$ пусте.  Тодў  $u   =   p_{i_{t+1}}^{g_{t+1}}\ldots
p_{i_q}^{g_q}$ належить  до  $H(P)$ ў тому $H(P) = H$.  З другого
боку, оскўльки $P = H$, то $H(P) = H$. $\blacksquare$

З цўї∙ леми  випливаї,  що  коли  заданў  множини  твўрних  групи
$T_D(R)$ ў множина $P$, то група $H(P)$ цим визначаїться повнўстю.
Побудова вўдповўдного алгоритма зводиться до послўдовного застосування
алгоритмўв композицў∙ ў побудови нўльсенўвсько∙ системи твўрних.

Для остаточного розв'язання задачў про спўввўдношення необхўдно
вмўти будувати базис множини $ef(M,y)$. Врахування множини $M$
виконуїться дещо складнўше, нўж в попереднўх випадках, оскўльки
множина $M$, взагалў кажучи, в даному випадку не ї нормальною
конгруенц∙їю.

Нехай $p = y_1y_2\ldots y_n$ -- непусте  нескорочуване  слово  ўз
$T_D(R)$ таке,  що $l(p) > 2$,  де $y_i \in R \cup R^{-1},  \ i =
1,2,\ldots ,n.$

Слово $p$ називаїться циклўчно нескрочуваним, якщо воно приведене
ў $y_1y_n \not= e$, тобто коли в словў $p$ перший ў останнўй символи
не ї взаїмно оберненими.

Слово $p'= y_ny_1\ldots y_{n-1}$ називаїться  циклўчною  перестановкою
слова $p$.

Нехай $P  = \{p_1,\ldots,  p_k\}$ -- нўльсенўвський базис множини
$M$, де всў $p_i$ ўз $P$ циклўчно нескорочуванў,ў  $y  =  \{r_1:=
g_1,\ldots, r_m := g_m\}$ -- оператор присвоювання. Серед елементўв
оператора $y$ можуть бути елементи,  що мають вигляд $r_i := r_i,
\ r_i \in R, \ i = 1,2,\ldots, m$ (якў не змўнюють значення $r_i$).
За множиною $P$ побудуїмо такў двў множини $P'$ ў $Q$.
Множину $P'$  складають тў слова ўз $P$,  якў включають тў $r_i$,
значення яких не змўнюються оператором $y$.  Множина $Q$  включаї
рўвностў вигляду $p' = p$ такў, що $p'p^{-1} = p_i \in {\bar P} =
P \cup \{p_1^{-1},\ldots, p_k^{-1}\}$ або $p'p^{-1}$ ї циклўчною
перестановкою деякого слова ўз $P$,  причому коли $l(p') = l(p)$,
то $p' = p \in Q$, a $p = p' \notin Q$ (або навпаки).

Нехай $q \in Q$ ў $q[q_1 \gets q_2]$ означаї пўдстановку  замўсть
деякого входження слова $q_1$ в слово $q$ слова $q_2$.  При цьому
пўдстановка називаїться незростаючою,  якщо $l(q) > l(q[q_1 \gets
q_2])$, де $q$ ў $q[q_1 \gets q_2]$ -- приведенў слова. Зауважимо,
що  число  елементўв у множинў $Q$ обмежене величиною
\begin{center}
            $\sum\limits_{i=1}^k l(p_i) < 2(L(P))^2$.
\end{center}

Побудувавши множини  $P'$  ў $Q$,  починаїмо факторизацўю слўв ўз
$Q' = \{g_1,\ldots,  g_m\}$ (де $g_i$ -- правў частини  елементўв
оператора присвоювання $y$) вўдносно множини $Q$. Факторизувати
множину $Q'$ вўдносно $Q$  означаї  виконання  всўх  незростаючих
пўдстановок ўз $Q$ на елементах $Q'$ до тих пўр,  доки нўяка
незростаюча пўдстановка не буде застосовна  (тобто нў  одна  ўз
пўдстановок не зменшуватиме сумарну довжину множини $Q'$).

Врахування множини $P$ (базиса множини $M$)  на  входў  оператора
$y$ тепер  зводиться до почергового застосування процедури факторизацў∙
ў алгоритма НЎЛ до тих пўр, доки результатом процедури факторизацў∙
не буде пуста пўдстановка. Оскўльки пўсля кожно∙ ўтерацў∙ (за винятком
останньо∙) сумарна довжина
\begin{center}
                  $\sum\limits_{i=1}^m l(g_i)$
\end{center}
зменшуїться, то не бўльше нўж через $l$ ўтерацўй процес завершиться.
Знайшовши множину рўвностей вигляду (\ref{5.1.2}) ў приїднавши до
нього множину $P'$, отримуїмо базис множини $ef(M,y)$.

Оцўнимо часову складнўсть всього процесу факторизацў∙, покладаючи
$n = L(P), \  N = \max (l,n)$.  Побудова множини $P'$ може бути
виконано за один перегляд слўв ўз $P$ ў  лўвих  частин  елементўв
оператора $y$,  у якого елементи вигляду $r_i := r_i$ попередньо
позначенў. Це вимагаї $O(m+n)$ часу. Число елементўв у множинў $Q$
буде не  бўльше нўж $2n\cdot n = 2n^2$.  Побудова множини $Q$ теж
вимагаї $2n$ одиниць часу, а складнўсть ўдентифўкацў∙ $2n^2$
ланцюжкўв ў пўдланцюжкўв в словў $g$ пропорцўональна величинў
$l(g)+l(p_1) +\ldots + l(p_k) < l(g) + 2n^2$ \cite{ahu}. Тому
часова складнўсть  всўї∙ процедури факторизацў∙ виражаїться величиною
$m + n + 2n^2 + l + 2n^3l \sim O(N^4)$.

Приймаючи до уваги складнўсть алгоритма побудови нўльсенўвсько∙
системи твўрних,  отримуїмо оцўнку часово∙ складностў всього процесу
побудови базиса $ef(M,y)$ -- $l(N^4 + k\cdot l^2) \sim O(N^5)$.


\subsection{Розв'язок задачў про перетин}
\ \ \ \ З вищесказаного випливаї, що задача про перетин в даному
випадку зводиться до пошуку перетину скўнченного числа нормальних
дўльникўв, породжених скўнченними множинами слўв.

Перша труднўсть,  яка лежить на шляху точного розв1язнання задачў
про  перетин полягаї в тому, що цў нормальнў дўльники, взагалў
кажучи, можуть не бути  скўнченно  породженими  пўдгрупами  групи
$T_D(R)$, тобто можуть не мати скўнченних базисўв. В зв'зку з цим
приходиться вводити додатковў обмеження на пўдгрупи групи $T_D(R)$,
а саме,  умови скўнченно∙ породжуваностў нормальних пўдгрупп, якў
складають множини спўввўдношень лўнўйних ланок.  Таке  обмеження,
природно веде до бўднўших множин ўнварўантўв,  тим не менше,  даї
практичний шлях побудови цих множин (або ∙х базисўв).  Розглянемо
розв'язок задачў про перетин в цьому випадку.

Вўдомо, що перетин скўнченного числа скўнченно породжуваних
пўдгруп вўльно∙ групи  сам  ї  скўнченно  породжуваною  пўдгрупою
\cite{127}.  Але, перше доведення цього факту не було конструктивним.
Бўльш нўж через 20 рокўв питання побудови вўдповўдного  алгоритма
був розглянутий з позицўй теорў∙ автоматўв, завдяки чому було
доведено ўснування алгоритма \cite{104}.  В роботах \cite{44, 47}
запропоновано алгоритм побудови базиса  перетину двох скўнченно
породжених вўльних груп, який маї полўномўальну оцўнку часово∙
складностў, викладення якого наводиться нижче.


{\bf Скелетне дерево.} Нехай $T$ -- скўнченне орўїнтоване дерево,
дуги якого позначенў символами алфавўта $X \bigcup X^{-1}$. Вершини
дерева $T$ будемо називати станами. Якщо ўз стану $i$ в стан $i'$ веде
дуга, позначена символом $x$ алфавўта $X$, то трўйку $(i,i',x)$
називають переходом. Шляхом з вершини $i$ у вершину $j$ назвемо
послўдовнўсть станўв $i= i_1,i_2, \ldots, j_k = j,$ зв'язаних
переходами $(i_{p-1}, i_p, x_{p-1}), p = 2,\ldots, k$, a
$x_1x_2\ldots x_{p-1}$ -- словом, яке вўдповўдаї цьому шляху.

Нехай $T$ маї $n$ вершин-листкўв ў нехай $Q = \{q_1,q_2,\ldots,q_n\}$
-- скўнченна послўдовнўсть слўв в алфавўтў $X \bigcup X^{-1}$.
Занумеруїмо вершини листки дерева $T$ цўлими числами вўд одиницў до $n$,
виконуючи ∙х обхўд злўва направо зверху вниз.

Дерево $T$ називаїться скелетним для множини $Q$,  якщо для шляху
$h$ з початково∙ вершини $a_0$ дерева $T$ у вершину-листок з номером
$l \  (l  = 1,\ldots,n)$,  слово $p$,  що вўдповўдаї цьому шляху,
збўгаїться зў словом $q \in Q$. Причому для довўльного початкового
пўдслова $p'$ слова $q$ в $T$ ўснуї їдина вершина $j$ така, що
$p'$ вўдповўдаї шляху з $a_0$ в $j$ (див.  нижченаведений приклад
2.9.3).  Скелетне  дерево  $T$  для  множини  $Q$ позначатимемо через
$T_Q$.  Зауважимо,  що число вершин дерева $T_{Q}$ (тобто,  число
станўв) не перевищуї величини $L(Q)+1$, де $L(Q)$ -- сумарна довжина
слўв послўдовностў $Q$.

Ўснування ў спосўб побудови шуканого алгоритма випливаї ўз
тако∙ теореми.
\begin{theorem}
Пўдгрупа вўльно∙ групи скўнченно породжувана тодў ў тўльки тодў,
коли множина ∙∙ слўв ї регулярною множиною \cite{kri4}.
\end{theorem}

     {\em Доведення.} Нехай $H$ --  скўнченно породжувана  пўдгрупа
вўльно∙  групи ў $P = \{p_1,\ldots,  p_m\}$ ∙∙ нўльсенўвський базис.
Позначимо через $\overline{P}=\{p_{1}, \ldots, p_m, p_{m+1},
\ldots,  p_{2m}\}$ ``розширений'' нўльсенўвський базис групи $H$,
в якўй $p_{m+1} = p_{1}^{-1},  \ldots,  p_{2m}=p_{m}^{-1}$. Нехай
$T_{\overline{P}}$ -- скелетне дерево для множини $\overline{P}$.
Побудова графа переходўв автомата $A_{H}$,  який  акцептуї  слова
групи $H$, виконуїться шляхом введення нових переходўв мўж станами
дерева $T_{\bar P}$.  Цў переходи визначаються таким чином:

{\bf початок}

Для всўх $p_{k},  p_{t}$ ўз $P$ таких,  що $p_{k}p_{t} \not=  e$,
виконуїться така послўдовнўсть дўй:

1) Покласти $s = 1$.

2) Взяти       в      $T_{\overline{P}}$      перший      перехўд
 $(a_{0},i_{ts},x_{ts})$, який вўдповўдаї слову $p_{t}$, ў останнўй
 перехўд $(j_{kq-1},j_{kq},x_{kq})$,  який  вўдповўдаї останньому
 переходу $p_{k}$.

3) Якщо символи $x_{ts}$ ў $x_{kq-s+1}$ не ї взаїмно оберненими, то
 перейти на крок 7).

4) Збўльшити $s$ на одиницю.

5) Взяти в  $T_{\overline{P}}$  перехўд  $(i_{tq-1},  i_{tq-s+1},
 x_{t-s+1})$,   який   вўдповўдаї   слову   $p_{t}$,   ў  перехўд
 $(j_{kq-1},  j_{kq-s+1},  x_{q-s+1})$,  який  вўдповўдаї   слову
 $p_{k}$.

6) Перейти на крок 3.

7) Визначити перехўд ўз  стану $j_{kq-s+1}$  в  стан $i_{ts}$  пўд
 дўїю символа $r_{ts}$.

{\bf кўнець}

Ўз способу побудови автомата $A_{H}$ очевидним чином випливаї, що
$A_{H}$ -- детермўнований ў група $H$ представлена в ньому множиною
станўв $F$,  якў в деревў $T_{\overline{P}}$ були вершинами-листками.
(Зауважимо, що  дерево  $T_{\overline{P}}$  збўгаїться з остовним
деревом графа переходўв автомата $A_H$).

Нехай тепер  множина слўв  групи $H$  --  регулярна множина ў $A_H$ --
скўнченний детермўнований  автомат  без  виходўв, в якому $H$
представлена деякою множиною станўв $F$.  Використовуючи  один  з
алгоритмўв аналўзу  скўнченних  автоматўв без виходу,  описаних в
попереднўх роздўлах, побудуїмо регулярний вираз $R_{H}$ для мови,
що акцептуїться множиною станўв $F$. Замўнимо тепер в $R_{H}$ всў
вирази вигляду $\{p\}$, якў входять в його запис, виразами вигляду
($e \vee p$),  тобто ўтерацўйнў дужки замўнюїмо круглими, а вирази в
дужках -- диз'юнкцўїю $e \vee p$, де $e$ -- пусте слово. Застосовуючи
закони дистрибутивностў   до  перетвореного  таким  чином  вираза
$R_H$, приведемо його до вигляду $e \vee p_1 \vee p_2 \vee \ldots
\vee p_n$.   Сверджуїться,   що   множина   $\bar P  =  \{p_i  |  i  =
1,\ldots,n\}$ ї множиною твўрних групи $H$. Для цього покажемо, що
довўльне слово  $p  \in H$ можна подати у виглядў добутку слўв ўз
$\overline{P}$.

Нехай $a_0h_0a_0x_{i1}a_{j1}h_1a_{j1}x_{i2}a_{j2}\ldots x_{ik}
a_{jk} h_k a_{jk} x_{ik+1} a_k$ -- шлях в $A_H$, якому вўдповўдаї
слово $p$,  де $a_k \in F$, $a_0$ -- початковий стан $A_H$, $h_i$
-- шляхи типу $a_{ji}[a_0,\ldots, a_{ji-1}]$. За побудовою множини
$\bar P$ маїмо,  що слово  $x_{i1}x_{i2}\ldots  x_{ik+1},  \in
\bar  P$,  (оскўльки  воно  вўдповўдаї  простому  шляху з $a_0$ в
$a_k$),  $q_0  x_{i1}\ldots  x_{ik+1},x_{i2}   q_1   x_{i2}\ldots
x_{ik+1},  \ldots,  x_{i1}^{-1}  x_{i2}^{-1}\ldots  x_{il+1}^{-1}
q_{l+1}x_{il+1} \in P$,  де $q_i$ пробўгаї всю множину слўв,  якў
вўдповўдають шляхам типу $a_{ji} [a_0, \ldots , a_{ji-1}], i = 0,
1,  \ldots, a_{j0} = a_0$. Оскўльки $H$ -- група, то $q_0 \in H$,
${x_{i1}q_{1}x_{i1}}^{-1}     ,\ldots,     x_{i1}x_{i2}    \ldots
{x_{il}q_{l}x_{i1}}^{-1}      \ldots      x_{i2}^{-1}x_{i1}^{-1},
x_{i1}^{-1}x_{i2}^{-1}   \ldots $ ${x_{i1+1}}^{-1}q_{l+1}x_{il+1}
\ldots x_{i2}x_{i1},\ldots,$ $x_{ik+1}^{-1}q_{k}x_{ik+1}  \in  H$  ў
подаїться у виглядў добутку слўв ўз $\bar P$. Тепер стаї очевидним
можливўсть подання слова $p_{i}$ у виглядў добутку  слўв  $p$
ўз  $\overline{P}$.  Дўйсно,  довўльне слово $h$,  яке вўдповўдаї
шляху типу  $a_{0}[a_{0}]$,  подаїться  у  виглядў  добутку  слўв
$q_{0}$,   оскўльки   вони   охоплюють   всў  простў  шляхи  типу
$a_{0}[a_{0}]$.  Можливўсть подання решти  $h_{i}  (i=1,k)$,  якў
входять в слово $p$,  випливаї ўз спряженостў слўв $q_{i}$ (слова
$p$ ў $q$ групи називаються спряженими,  якщо в нўй  ўснуї  слово
$r$ таке,  що $p = r^{-1}qr$).  Отже, $p$ подаїться у виглядў
добутку $$(\prod \limits_{j=1}^{m _{0}}q _{0j}^{\varepsilon _{j0}})
(\prod   \limits   ^{m   _{1}}   _{j=1}(x   _{j1}q  _{1j}x  _{j1}
^{-1})^{\varepsilon_{j1}})             \ldots              (\prod
\limits^{m_{k}}_{j=1}(x_{jk+1}^{-1}q_{jk}  x_{jk+1})^{\varepsilon
_{jk}}) = \prod \limits ^{m} _{j=0}p _{j} ^{\varepsilon  _{j}},$$
де $p_j \in P,  \varepsilon_{j} = \pm 1,\varepsilon_{j1} = \pm 1,
l = 0,\ldots, k$.

   В силу довўльностў слова $p$ ў з алгоритму аналўза скўнченних
автоматўв випливаї, що $\bar P$ -- скўнченна множина ў ї множиною
твўрних групи $H$. $\blacksquare$

З доведено∙ теореми випливаї класичний результат теорў∙ скўнченно
породжуваних вўльних груп \cite{hau}.

\begin{theorem} ({\bf Теорема (Хаусона)}).
Перетин скўнченного числа скўнченно породжуваних вўльних  груп  ї
скўнченно породжуваною вўльною групою.
\end{theorem}

Розглянемо деякў властивостў автомата $A_{H}$, побудованого при
доведеннў вищенаведено∙ теореми.

Стан $i$ автомата $A_{H}$ називаїться розгалуженням, якщо ўснують
$x_{1},x_{2} \in X \cup X^{-1}$ ў стани $j_{1},  j_{2}$ такў,  що
$x_{1}  \  \not=  \  x_{2}$  ў   $\delta   (i,x_{1})   =   j_{1},
\delta(i,x_{2}) = j_{2}$,  де $\delta$ -- функцўя переходўв автомата.

   Розгалуження $i$  називаїться еквўвалентним розгалуженню $j (i
\sim j)$, якщо для деяких слўв $q_{i}$ ў $q_{j}$  таких,  що
$\delta(a_{0},q_{i}) = i,  \delta(a_{0},q_{j}) = j$  маї  мўсце
включення $q_{i}q_{j}^{-1} \in H$.  Якщо $i \sim j$ ў $q_i,  q_j$
-- деякў слова такў, що $\delta(a_0,q_i) = i, \delta(a_{0},q_{j})
= j$,  то для довўльного слова $q$ такого,  що $\delta(a_{0},q) =
i$ маї мўсце включення $qq_{j}^{-1} \in H$.  Дўйсно, нехай $q_{1}
= \bar {q_{i}}y,  q_{j} = \bar {q_{j}}y,  y = \bar {y}y_{1},  q =
\bar {q}y_{1}$ ў,  отже, $q_{i} = \bar {q_{i}}\bar {y}y_{1},q_{j}
= \bar {q_{j}}\bar {y}y_{1}$.  За умовою маїмо $q_{i}q_{j}^{-1} =
(\bar    {q_{i}}\bar   {y}y_{1})   (y_{1}^{-1}\bar   {y^{-1}}\bar
{q_{j}^{-1})} = \bar {q_{i}}\bar {q_{j}^{-1}} \in H$.  Ўз способу
побудови автомата $A$ очевидним чином випливаї,  що ўз довўльного
стану $i$ досяжний деякий заключний стан $j$.  Це означаї, що
ўснуї деяке слово $z$ таке, що $\delta(i,z) = j$ -- заключний стан.
Тодў $qq_i^{-1} =  \bar  q  \bar  y^{-1}  \bar  q_i^{-1}  =  (qz)
(z^{-1}q_i^{-1})   \in   H$   ў   $(\bar  q\bar  y\bar  q_i^{-1})
(q_iq_j^{-1})  =  (\bar  q\bar  y\bar  q_i^{-1})(\bar  q_i\bar  y
y_1y_1^{-1}\bar  y^{-1}\bar q_j^{-1} = qq_i^{-1}) \in H$.  Звўдси
випливаї, що для кожного $q_j$ такого, що $\delta(a_0, q_j) = j$,
ў  $q$  такого,  що $\delta(a_0,  q) = i$,  мають мўсце включення
$q_jq^{-1}, qq_j^{-1} \in H$.

   Безпосередньо ўз способу побудови автомата $A_{H}$ випливають
такў його властивостў:

   1. всў переходи,  якў ведуть в даний стан $i$, позначенў одним
ў тим самим символом $x \in X \cup X^{-1}$;

   2. кўлькўсть заключних станўв $A_{H}$  не  перевищуї  величини
$L(\bar P) + 1 = 2*L(P)+1$, де $L(P)$ -- сумарна довжина нўльсенўвського
базису групи $H$;

   3. кўлькўсть заключних станўв $A_{H}$ задовольняї нерўвностў
$2m \leq 2|P|$ + 1;

   4. нехай $i$ ў $j$ розгалуження ў $i \sim j$. Тодў, якщо ўз
стану $i$ ї перехўд,  позначений символом $x \in X \cup  X^{-1}$,
то ўз $j$ теж ї перехўд, позначений тим же символом $x$, при умовў,
що $x$ ў $x_{1}$ не взаїмно оберненў символи, де символом $x_{1}$
позначенў переходи, якў ведуть в стане $j$ (див. властивўсть 1).

Дўйсно, оскўльки $i \sim j$, то для всўх $q_{i}, q_{j}$ таких, що
$\delta(a_{0},q_{i})    =    i,    \delta(a_{0},q_{j})    =    j,
q_{i}q_{j}^{-1}, q_{j}q_{i}^{-1} \in H$ ў для кожного $q$ такого,
що  $q_{i}q  \in H$ маїмо $(q_{j}q_{i}^{-1})(q_{i}q) = q_{j}q \in
H$.

\begin{lemma}
Розгалуження дерева  $T_{P}$  попарно  не еквўвалентнў.  Довўльне
розгалуження автомата $A_{H}$ еквўвалентне деякому розгалуженню
дерева $T_{P}$.
\end{lemma}

   {\em Доведення.} Нехай $i, j$ -- розгалуження дерева $T_{P}$ ў
припустимо, що $i \sim j$. Це означаї, що для всўх $q_{i},q_{j}$ таких, що
$\delta(a_{0},q_{i}) =  i,  \delta(a_{0},q_{j})  =  j$  маї мўсце
включення $q_{i}q_{j}^{-1} \in H$  ў,  отже,  $q_{i}q_{j}^{-1}  =
p_{i1} \ldots p_{ik}$,  де $p_{il} \in \bar P,  l = 1,\ldots,k$.  Тодў
$p_{i1} =  q_iu,$  a  $p_{ik}  =  vq_j^{-1}$, де  $l(u)  \geq
l(q_{i})$ ў $l(v) \geq l(q_{j}^{-1})$ на пўдставў  нўльсенўвсько∙
властивостў множини   $P$.   Але   слово   $q_{i}up_{i2}   \ldots
p_{ik-1}vq_{j}^{-1}$ включаї нескорочуванў символи,  знову ж таки
на пўдставў нўльсенўвсько∙ властивостў $P$. Отримана суперечнўсть
доводить першу частину леми.

Нехай $i$ розгалуження автомата $A_{H}$ ў $i$ не ї розгалуженням
дерева $T_{\bar P}$. Тодў $q_ie = q_i \in H$ ў $i \sim a_{0}$.

   Якщо $i$ не ї станом-листком дерева $T_{\bar P}$, то за побудовою
автомата $A_{H}$  маїмо,  що  ўснуї принаймнў два слова $p_i$ ў
$p_j$ $\bar P$ такў, що у слўв $p_{i}$ ў $p_{j}$ ї спўльне початкове
пўдслово $p$.  Тодў стан $j$, в який автомат переходить пўд дўїю
слова $p$,  буде  еквўвалентним  стану $i$. $\blacksquare$

Очевидно, що вўдношення $\sim$ мўж розгалуженнями ї вўдношенням
еквўвалентностў ў  всў розгалуження розбиваються на класи
еквўвалентностў за цим вўдношенням.

{\bf Побудова множини твўрних за автоматом $A_{H_1 \cap H_2}$.}
Нехай дано автомат $A_{H_1} \cap A_{H_2}$,  який  акцептуї  слова
групи  $H_1  \cap H_2$ множиною станўв $F$.  Вўдомо,  що $A_{H_1}
\cap A_{H_2}$ ї прямим добутком автоматўв $A_{H_1}$ ў  $A_{H_2}$.
Цей автомат будемо далў позначати $A_{H_1 \cap H_2}$.
Вилучимо  в  автоматў $A_{H_1 \cap H_2}$ тў стани, з яких недосяжнў
стани множини $F$, а також  всў переходи, якў ведуть в такў стани.
Зауважимо,  що для $A_{H_1 \cap H_2}$ будуть справедливў
властивостў 1, 3, 4, про якў говорилось вище.

Нехай $i_{1}, i_{2},\ldots, i_{k}$ -- представники класўв
еквўвалентностў розгалужень автомата  $A_{H_1 \cap  H_2}$.
Кожному стану $i_j (j = 1,\ldots, k)$ поставимо у вўдповўднўсть
слово $p_j$,  яке переводить автомат $A_{H_1 \cap  H_2}$  ўз
$a_0$ в $i_j$ по деякому простому шляху.

     Для всўх слўв $p_j$ виконаїмо побудови, якў проўлюструїмо
на прикладў слова $p_1$.

Зў стану $i_1$, виконуючи лўвостороннўй обхўд графа переходўв
$A_{H_1 \cap H_2}$, переходимо в стан $i$ ў запам'ятовуїмо слово
$q$ що вўдповўдаї пройденому шляху, до тих пўр, доки не зустрўнемо
одну ўз таких ситуацўй:

     1) стан $i$ -- розгалуження;

     2) стан $i \in F$;

     3) потрапили в цикл, тобто стан $i$ вже зустрўчався на шляху,
        якому вўдповўдаї слово $p_1q$.

     В залежностў вўд ситуацў∙ виконуються такў дў∙:

     1. а) якщо $i \sim i_{j}$ ў $i_{j} \not = i$, то заносимо
слово \ $p_{1}qp_{j}^{-1}$ до множини $P$, повертаїмося в стан
$i_1$ ў продовжуїмо обхўд;

     1. б) якщо $i \sim i_{j}$ ў $i = i_{j}$, то якщо $p_1q = p_j$,
то запам'ятовуїмо слово $p_1q$ ў починаїмо обходи зў стану $i$ так
само як ў зў стану $i_1$;

     2. заносимо слово $p_1q$ до множини $P$, повертаїмося в стан
$i_1$ ў рухаїмося далў згўдно з правилами обходу;

     3. повертаїмося в стан, з якого був виконаний перехўд в стан
$i$, ў продовжуїмо обхўд далў.

На пўдставў того,  що число станўв  автомата  $A_{H_1  \cap  H_2}$
скўнченне, то  процес побудови $P$ завжди закўнчуїться.  Одержана
множина слўв маї властивўсть, яку даї
\begin{lemma}
                  $G_P(X) = H_{1} \cap H_{2}$.
\end{lemma}

{\em Доведення.} Покажемо, що довўльне слово $p \in H_1 \cap H_2$
можна подати у виглядў добутку слўв ўз $P$ ў  до  них  обернених.
Зазначимо, що  оскўльки  $P  \subseteq H_1 \cap H_2$,  то $G_P(X)
\subseteq H_1 \cap H_2$.

Нехай $h$  -- шлях ўз початкового стану $a_{0}$ в стан $a \in F$,
якому вўдповўдаї слово $p$ ў $j_1, j_2,\ldots, j_n$ -- послўдовнўсть
всўх станўв-розгалужень, якў зустрўчаються на цьому шляху. Тодў слово
$p$ можна подати у виглядў добутку слўв $q_{0},q_{1},\ldots, q_{n}$
таких, що $\delta (a_0, q_0) = j_1, \ldots, \delta(j_n, q_n) = a_p$,
причому для довўльного початкового вўдрўзка $q_j$ слова $q_{j}l$
стан $f(j_l, q_j)$ не ї розгалуженням $(l = 0,\ldots, n)$.
Нехай $j_1 \sim i_1 \in \{i_{1},\ldots,i_{k}\}$, тодў за побудовою
множини $P$ в нўй ўснуї елемент $p_{t1}q_0$ (або обернений до нього).
Розглянемо слово $p_1 = p_{t1}q_1 \ldots q_n$.  На пўдставў тих же
причин в  множинў  $P$  ўснуї елемент $p_{t1}q_1p_{t2}^{-1}$ (або
обернений до нього). Розглянемо слово $p_{t2}q_2 \ldots q_n$ ў т.д.
Зрештою приходимо до пустого слова $p_{tn}q_n$,  яке знову ж таки
на пўдставў побудови $P$ ї його елементом. Отже, $H_1 \cap H_{2} =
G_P(X)$ ў разом з включенням, отриманим ранўше, маїмо $H_1 \cap H_2 =
G_P(X)$.

Визначимо число елементўв у множинў $P$.  Очевидно,  що коли $l =
(i,j)$  --  розгалуження  автомата $A_{H_1 \cap H_2}$,  то $i$ --
розгалуження автомата $A_{H_1}$,  а $j$ --  розгалуження  автомата
$A_{H_2}$. Крўм  того,  якщо  $l  =  (i,j)$ ў $l_{1} = (i_1,j_1)$
розгалуження автомата $A_{H_1 \cap H_2}$  такў, що  $l  \sim
l_{1}$,  то  $i  \sim  i_{1}$  в автоматў $A_{H_1}$,  а $j \sim
j_{ў1}$ в автоматў $A_{H_2}$.

Нехай тепер $l = (i,j)$ --  розгалуження  автомата  $A_{H_1  \cap
H_2}$, тодў йому однозначно вўдповўдаї пара класўв $(K_1, K_2)$
автомата $A_{H_1}$ ў автомата $A_{H_2}$ вўдповўдно така, що
$i \in K_1$,  $j \in K_2$.  Причому пара $(K_1, K_2)$ не залежить
вўд вибору $l$ з даного класу еквўвалентностў, якому належить $l$.
Тодў число  $k$ класўв  еквўвалентностў розгалужень автомата
$A_{H_1 \cap H_2}$ не перевищуї  величини $(K_1, K_2)$,
де $(K_1, K_2)$ -- число класўв еквўвалентностў розгалужень
автомата $A_{H_1}$ ў автомата $A_{H_2}$ вўдповўдно.

На пўдставў попередньо∙ леми маїмо $k \leq  (2m-1)  \cdot  (2n-1)
\leq  4|P_{1}|  \cdot |P_{2}|$,  де $m = |P_{1}|$,  $n=|P_{2}|$.
Число переходўв з довўльного стану $A_{H_1 \cap H_2}$ не  перевищуї,
очевидно, величини $2 min (|P_{1},P_{2}|)$,  тому число елементўв
множини $P$  обмежене  величиною  $8 \min (|P_{1}|,|P_{2}|) \cdot
|P_{1}|\cdot |P_{2}|$. $\blacksquare$

\begin{center}
     {\bf Алгоритм побудови базиса групи $H_1 \cap H_2$.}
\end{center}

З усього вищеописаного випливаї алгоритм побудови базиса групи
$H_1 \cap H_2$, який наводиться нижче.
\begin{center}
                         ПЕРЕТИН $(P_1, P_2)$.
\end{center}

{\bf початок}

\hspace{1cm} 1. Побудувати автомат $A_{H_1}$ за множиною $P_1$;

\hspace{1cm} 2. Побудувати автомат $A_{H_2}$ за множиною $P_2$;

\hspace{1cm}  3. Побудувати автомат $A_{H_1 \cap H_2}$;

\hspace{1cm} 4.  Вилучити стани в $A_{H_1 \cap H_2}$,  з яких
                 недосяжнў заключнў стани;

\hspace{1cm} 5. Побудувати $P$ за автоматом $A_{H_1\cap H_2}$;

\hspace{1cm} 6. Побудувати нўльсенўвський базис для $P$;

{\bf кўнець}\\

Розглянемо приклади застосування розглянутих алгоритмўв.

{\bf Приклад 2.9.3} побудови автомата за нўльсенўвським базисом.
Розглянемо розширений оберненими елементами нўльсенўвський базис
$P = \{a^2,a^{-2},ab,  b^{-1}a^{-1}\}$.

Будуїмо скелетне дерево для даного базиса $P$.

\vspace{0.3cm}

\unitlength=1mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(90.33,40.67)
\put(55.00,37.67){\circle{6.00}}
\put(55.00,37.67){\circle{4.67}}
\put(55.00,37.67){\makebox(0,0)[cc]{{\tiny 0}}}
\put(55.00,34.67){\vector(-3,-2){15.00}}
\put(37.33,22.00){\circle{5.33}}
\put(55.00,34.33){\vector(0,-1){9.67}}
\put(55.00,22.00){\circle{5.33}}
\put(55.00,34.33){\vector(3,-2){13.67}}
\put(70.33,22.00){\circle{5.33}}
\put(65.00,30.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(44.33,30.33){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(53.00,28.67){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(55.00,22.00){\makebox(0,0)[cc]{{\tiny 6}}}
\put(70.33,22.00){\makebox(0,0)[cc]{{\tiny 3}}}
\put(37.33,22.00){\makebox(0,0)[cc]{{\tiny 1}}}
\put(36.00,19.67){\vector(-4,-3){10.67}}
\put(22.67,9.00){\circle{5.33}}
\put(22.67,9.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(22.67,9.00){\circle{4.00}}
\put(55.00,19.33){\vector(-1,-1){8.00}}
\put(44.33,9.00){\circle{5.33}}
\put(44.33,9.00){\circle{4.00}}
\put(44.33,9.00){\makebox(0,0)[cc]{{\tiny 7}}}
\put(47.67,16.33){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(28.00,16.33){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(55.00,19.00){\vector(1,-1){7.67}}
\put(65.33,8.67){\circle{5.33}}
\put(65.33,8.67){\circle{4.00}}
\put(65.33,8.67){\makebox(0,0)[cc]{{\tiny 5}}}
\put(60.33,16.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(70.67,19.33){\vector(1,-2){4.00}}
\put(76.67,8.67){\circle{5.33}}
\put(76.67,8.67){\circle{4.00}}
\put(72.33,20.00){\vector(3,-2){13.00}}
\put(87.67,8.67){\circle{5.33}}
\put(87.67,8.67){\circle{4.00}}
\put(87.67,8.67){\makebox(0,0)[cc]{{\tiny 4}}}
\put(76.67,8.67){\makebox(0,0)[cc]{{\tiny 8}}}
\put(81.00,16.33){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(70.33,15.00){\makebox(0,0)[cc]{{\tiny $a$}}}
\end{picture}

Застосовуючи наведений в доведеннў теореми спосўб побудови  автомата,
отримуїмо граф переходўв автомата, який акцептуї слова групи
$G_P(X)$, де $A = (\{0,1,2,,3,4,5,6\}, X = \{a,b\}, \{0\}, f, F =
\{0,2,4,5\}$ (цей автомат мўнўмўзований,  в результатў чого стани
2, 7 ў 5, 8 ``скле∙лися'').

\vspace{0.4cm}

\unitlength=1.2mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(85.33,52.33)
\put(55.00,50.00){\circle{4.67}}
\put(55.00,50.00){\circle{4.07}}
\put(54.33,47.67){\vector(-2,-1){24.33}}
\put(27.33,33.67){\circle{4.67}}
\put(55.00,47.67){\vector(0,-1){12.33}}
\put(55.00,33.00){\circle{4.67}}
\put(55.00,47.67){\vector(2,-1){24.67}}
\put(82.67,33.00){\circle{4.67}}
\put(55.00,30.67){\vector(-4,-3){11.00}}
\put(42.00,20.00){\circle{4.67}}
\put(42.00,20.00){\circle{4.07}}
\put(55.00,30.67){\vector(4,-3){11.00}}
\put(68.67,20.00){\circle{4.67}}
\put(68.67,20.00){\circle{4.07}}
\put(27.33,31.00){\vector(0,-1){25.33}}
\put(27.33,3.00){\circle{4.67}}
\put(82.67,30.33){\line(0,-1){27.67}}
\put(82.67,2.67){\vector(-1,0){52.67}}
\put(27.33,3.00){\circle{4.07}}
\put(27.33,3.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(27.33,33.67){\makebox(0,0)[cc]{{\tiny 1}}}
\put(55.00,33.00){\makebox(0,0)[cc]{{\tiny 3}}}
\put(55.00,50.00){\makebox(0,0)[cc]{{\tiny 0}}}
\put(38.00,42.33){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(53.00,42.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(70.00,42.33){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(82.67,33.00){\makebox(0,0)[cc]{{\tiny 6}}}
\put(85.33,20.00){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(68.67,20.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(42.00,20.00){\makebox(0,0)[cc]{{\tiny 4}}}
\put(46.33,27.33){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(63.67,27.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(81.00,31.00){\vector(-1,-1){9.67}}
\put(29.00,31.67){\vector(1,-1){10.67}}
\put(29.00,5.33){\line(6,1){52.00}}
\put(80.67,14.33){\vector(0,1){16.33}}
\put(51.67,11.00){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(23.00,29.67){\vector(4,3){2.67}}
\bezier{140}(23.33,29.67)(13.00,20.00)(25.00,3.33)
\put(15.67,19.00){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(25.00,19.00){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(33.00,24.67){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(32.67,32.00){\vector(-2,1){2.67}}
\bezier{60}(32.33,32.00)(38.33,31.00)(41.33,22.33)
\put(38.33,31.00){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(54.00,27.00){\vector(1,4){0.67}}
\bezier{56}(53.67,27.00)(51.33,21.00)(44.33,20.00)
\put(56.33,27.33){\vector(-1,4){0.67}}
\bezier{56}(56.67,27.33)(58.67,21.67)(66.33,19.33)
\put(51.67,21.00){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(59.00,21.00){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(77.67,31.33){\vector(2,1){2.33}}
\bezier{52}(77.67,31.00)(71.33,29.33)(70.00,22.67)
\put(71.33,29.33){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(76.67,24.67){\makebox(0,0)[cc]{{\tiny $a$}}}
\end{picture}
$\spadesuit$

\vspace{0.3cm}

{\bf Приклад 2.9.4} побудови регулярного виразу для вўльно∙  групи,
задано∙ скўнченним автоматом. Нехай дано автомат, побудований
вище в попередньому прикладў.  Необхўдно знайти регулярний  вираз
для регулярно∙ мови,  яка представлена в цьому автоматў,  а потўм
за цим регулярним виразом знайти нўльсенўвський базис дано∙  групи.
Автомат маї  вигляд:  $A  = (A = \{0,1,2,3,4,5,6\},  X = \{a,b\},
\delta, \{0\}, F = \{0,2,4,5\})$, де функцўя переходўв задана
вищенаведеним графом переходўв.

     Застосуїмо алгоритм  елўмўнацў∙ станўв з метою одержання
регулярного виразу мови, акцептовано∙ цим автоматом.

Вилучаїмо стан 1 (як промўжний). Для цього стану вхўдними станами
ї 0, 2, 4, а вихўдними -- стани 2, 4.

\vspace{0.2cm}

\unitlength=1.00mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(101.00,61.00)
\put(30.33,58.33){\circle{5.33}}
\put(30.33,58.33){\makebox(0,0)[cc]{{\tiny 0}}}
\put(33.00,58.33){\vector(3,-2){14.33}}
\put(50.67,48.33){\circle{5.33}}
\put(50.67,48.33){\makebox(0,0)[cc]{{\tiny 1}}}
\put(30.33,48.33){\circle{5.33}}
\put(30.33,48.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(33.00,48.33){\vector(1,0){14.33}}
\put(30.33,38.33){\circle{5.33}}
\put(33.00,38.33){\vector(3,2){14.67}}
\put(53.33,48.33){\vector(2,1){11.00}}
\put(67.33,55.33){\circle{5.33}}
\put(53.33,48.33){\vector(3,-1){11.00}}
\put(67.33,43.67){\circle{5.33}}
\put(67.33,43.67){\makebox(0,0)[cc]{{\tiny 4}}}
\put(67.33,55.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(40.33,56.50){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(38.00,50.00){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(40.33,40.67){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(30.33,38.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(58.67,53.33){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(58.67,44.33){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(10.00,15.00){\circle{5.33}}
\put(12.67,15.00){\vector(4,1){25.67}}
\put(41.33,22.00){\circle{5.33}}
\put(13.00,14.67){\vector(4,-1){25.33}}
\put(41.67,7.00){\circle{5.33}}
\put(41.67,7.00){\makebox(0,0)[cc]{{\tiny 4}}}
\put(41.33,22.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(10.00,15.00){\makebox(0,0)[cc]{{\tiny 0}}}
\put(23.67,20.67){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(23.67,8.67){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(65.00,22.33){\circle{5.33}}
\put(67.67,22.33){\vector(1,0){27.33}}
\put(98.33,22.33){\circle{5.33}}
\put(62.67,23.33){\line(0,1){7.67}}
\put(62.67,31.00){\line(1,0){4.67}}
\put(67.33,31.00){\vector(0,-1){6.33}}
\put(65.00,22.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(71.00,28.00){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(82.00,24.33){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(65.00,7.00){\circle{5.33}}
\put(67.67,7.00){\vector(1,0){27.33}}
\put(98.33,7.00){\circle{5.33}}
\put(98.33,7.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(98.33,22.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(81.67,8.67){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(65.00,7.00){\makebox(0,0)[cc]{{\tiny 4}}}
\put(62.67,8.00){\line(0,1){7.67}}
\put(62.67,15.67){\line(1,0){4.67}}
\put(67.33,15.67){\vector(0,-1){6.67}}
\put(71.00,12.67){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\end{picture}

Пўсля вилучення стану 1 отримуїмо такий автомат:

\vspace{0.2cm}

\unitlength=1.1mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(107.00,56.01)
\put(55.00,53.33){\circle{5.37}}
\put(55.00,53.33){\circle{4.22}}
\put(55.00,53.33){\makebox(0,0)[cc]{{\tiny 0}}}
\put(55.00,50.66){\vector(-2,-1){20.00}}
\put(32.33,38.33){\circle{5.33}}
\put(55.00,50.66){\vector(0,-1){10.33}}
\put(55.00,37.66){\circle{5.33}}
\put(55.00,50.66){\vector(2,-1){20.00}}
\put(77.67,37.66){\circle{5.33}}
\put(77.67,35.00){\vector(-1,-1){11.67}}
\put(55.33,35.00){\vector(1,-1){10.67}}
\put(66.00,20.00){\circle{6.00}}
\put(78.00,35.00){\vector(1,-1){11.00}}
\put(90.33,20.33){\circle{6.04}}
\put(32.33,38.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(32.33,38.33){\circle{4.00}}
\put(42.33,47.33){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(52.33,45.33){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(55.00,37.66){\makebox(0,0)[cc]{{\tiny 6}}}
\put(65.33,47.66){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(77.67,37.66){\makebox(0,0)[cc]{{\tiny 3}}}
\put(70.33,31.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(61.00,31.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(66.00,20.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(90.33,20.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(84.67,31.66){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(78.00,28.33){\vector(0,1){6.33}}
\bezier{60}(78.00,28.33)(77.00,21.33)(69.00,20.66)
\bezier{64}(78.00,28.33)(80.67,19.66)(87.33,19.66)
\put(73.00,24.66){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(82.33,24.66){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(55.00,29.66){\vector(0,1){5.00}}
\bezier{64}(55.00,30.00)(55.00,23.00)(63.00,19.33)
\put(59.83,25.00){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(48.33,33.66){\vector(3,2){4.00}}
\bezier{72}(49.00,34.00)(39.33,30.33)(34.00,36.00)
\put(52.33,38.33){\vector(-1,0){17.00}}
\put(44.33,40.00){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(42.33,34.33){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(31.33,35.66){\line(-1,0){10.00}}
\put(21.33,35.66){\line(0,1){5.00}}
\put(21.33,40.66){\vector(1,0){9.00}}
\put(24.33,38.33){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(83.67,15.00){\vector(3,2){4.33}}
\bezier{288}(84.00,15.33)(59.00,0.66)(33.00,35.33)
\put(69.33,13.33){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(32.33,31.33){\vector(0,1){4.00}}
\bezier{380}(32.33,31.33)(51.67,-11.67)(90.33,16.66)
\put(51.67,10.66){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(92.00,17.33){\line(1,0){15.00}}
\put(107.00,17.33){\line(0,1){5.00}}
\put(107.00,22.33){\vector(-1,0){14.33}}
\put(97.00,19.66){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(91.33,28.33){\vector(0,-1){5.33}}
\bezier{232}(91.33,28.00)(91.00,53.00)(58.00,53.33)
\put(85.67,48.33){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(90.33,20.33){\circle{4.67}}
\put(66.00,20.00){\circle{4.67}}
\end{picture}

\vspace{-0.5cm}

Вилучаїмо стан 6 (як промўжний). Для цього стану вхўдними станами
ї 0, 2, 5, а вихўдними -- стани 2, 5.

\vspace{0.2cm}

\unitlength=1.00mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(100.99,71.00)
\put(30.33,58.33){\circle{5.33}}
\put(30.33,58.33){\makebox(0,0)[cc]{{\tiny 0}}}
\put(33.00,58.33){\vector(3,-2){14.33}}
\put(50.67,48.33){\circle{5.33}}
\put(30.67,48.33){\circle{5.33}}
\put(30.33,48.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(33.00,48.33){\vector(1,0){14.33}}
\put(30.33,38.33){\circle{5.33}}
\put(33.00,38.33){\vector(3,2){14.67}}
\put(53.33,48.33){\vector(2,1){11.00}}
\put(67.33,55.33){\circle{5.33}}
\put(53.33,48.33){\vector(3,-1){11.00}}
\put(67.33,43.67){\circle{5.33}}
\put(67.33,55.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(40.33,56.50){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(38.00,50.00){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(40.33,40.67){\makebox(0,0)[cc]{{\tiny $b^{-1}$}}}
\put(58.67,53.33){\makebox(0,0)[cc]{{\tiny $a^{-1}$}}}
\put(58.67,44.33){\makebox(0,0)[cc]{{\tiny a}}}
\put(10.00,15.00){\circle{5.33}}
\put(12.67,15.00){\vector(4,1){25.67}}
\put(41.33,22.00){\circle{5.33}}
\put(13.00,14.67){\vector(4,-1){25.33}}
\put(41.67,7.00){\circle{5.33}}
\put(41.33,22.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(10.00,15.00){\makebox(0,0)[cc]{{\tiny 0}}}
\put(23.67,20.67){\makebox(0,0)[cc]{{\tiny $a^{-2} \vee b^{-1}a^{-1}$}}}
\put(23.67,8.67){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(65.00,22.33){\circle{5.33}}
\put(67.67,22.33){\vector(1,0){27.33}}
\put(98.33,22.33){\circle{5.33}}
\put(62.67,23.33){\line(0,1){7.67}}
\put(62.67,31.00){\line(1,0){4.67}}
\put(67.33,31.00){\vector(0,-1){6.33}}
\put(65.00,22.33){\makebox(0,0)[cc]{{\tiny 2}}}
\put(73.00,28.00){\makebox(0,0)[cc]{{\tiny $b^{-1}a^{-1}$}}}
\put(82.00,24.33){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(65.00,7.00){\circle{5.33}}
\put(67.67,7.00){\vector(1,0){27.33}}
\put(98.33,7.00){\circle{5.33}}
\put(98.33,7.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(81.67,8.67){\makebox(0,0)[cc]{{\tiny $b^{-1}a^{-1}$}}}
\put(62.67,8.00){\line(0,1){7.67}}
\put(62.67,15.67){\line(1,0){4.67}}
\put(67.33,15.67){\vector(0,-1){6.67}}
\put(72.00,12.67){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(61.67,61.00){\vector(1,-1){3.67}}
\bezier{152}(62.00,60.67)(49.67,71.00)(30.33,61.00)
\put(48.00,63.33){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\put(30.33,38.33){\makebox(0,0)[cc]{{\tiny 5}}}
\put(50.67,48.33){\makebox(0,0)[cc]{{\tiny 6}}}
\put(67.33,43.67){\makebox(0,0)[cc]{{\tiny 5}}}
\put(65.00,7.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(41.67,7.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(98.33,22.33){\makebox(0,0)[cc]{{\tiny 5}}}
\end{picture}

Пўсля вилучення стану 6 отримуїмо такий автомат:

\vspace{0.2cm}

\unitlength=1mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(103.33,51.33)
\put(59.00,48.33){\circle{6.00}}
\put(59.00,48.33){\circle{4.67}}
\put(59.00,48.33){\makebox(0,0)[cc]{{\tiny 0}}}
\put(59.00,45.33){\vector(-3,-2){22.67}}
\put(33.67,28.67){\circle{6.00}}
\put(33.67,28.67){\circle{4.67}}
\put(33.67,29.00){\makebox(0,0)[cc]{{\tiny 2}}}
\put(35.67,40.67){\makebox(0,0)[cc]{{\tiny $a^{-2} \vee b^{-1}a^{-1}$}}}
\put(59.00,45.00){\vector(0,-1){13.33}}
\put(59.00,28.67){\circle{6.00}}
\put(59.00,28.67){\circle{4.67}}
\put(59.00,29.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(53.00,34.67){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(59.00,45.33){\vector(3,-2){22.00}}
\put(84.00,28.67){\circle{0.00}}
\put(84.00,28.67){\circle{6.00}}
\put(84.00,28.67){\makebox(0,0)[cc]{{\tiny 3}}}
\put(69.33,40.67){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(84.67,13.33){\circle{6.00}}
\put(84.67,13.33){\circle{4.67}}
\put(84.67,13.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(86.33,15.67){\vector(0,1){10.67}}
\put(82.67,26.33){\vector(0,-1){10.67}}
\put(80.33,20.67){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(88.00,20.67){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(86.67,16.00){\line(1,0){13.67}}
\put(100.33,16.00){\line(0,-1){5.00}}
\put(100.33,11.00){\vector(-1,0){13.67}}
\put(93.67,13.67){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(80.67,29.33){\vector(-1,0){19.00}}
\put(61.67,27.00){\vector(1,0){19.67}}
\put(56.33,29.33){\vector(-1,0){19.33}}
\put(36.67,27.00){\vector(1,0){19.67}}
\put(69.67,31.00){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(69.67,25.67){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(45.67,25.67){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(47.33,31.33){\makebox(0,0)[cc]{{\tiny $b^{-1}a^{-1}$}}}
\put(57.00,26.67){\line(0,-1){5.00}}
\put(57.00,21.67){\line(1,0){4.33}}
\put(61.33,21.67){\vector(0,1){4.67}}
\put(59.00,19.33){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(33.00,31.33){\line(0,1){6.33}}
\put(33.00,37.67){\line(-1,0){20.67}}
\put(12.33,37.67){\line(0,-1){9.67}}
\put(12.33,28.00){\vector(1,0){18.67}}
\put(22.33,33.00){\makebox(0,0)[cc]{{\tiny $(a^{-2})^* \vee (b^{-1}a^{-1})^*$}}}
\put(92.67,22.00){\vector(-1,-1){5.67}}
\bezier{248}(92.67,22.00)(103.33,39.33)(62.33,48.67)
\put(85.67,44.67){\makebox(0,0)[cc]{{\tiny $a^{-1}B$}}}
\put(74.00,13.33){\vector(1,0){7.67}}
\bezier{180}(74.33,13.33)(44.33,13.00)(35.33,25.33)
\put(55.00,11.33){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(34.67,20.00){\vector(-1,4){1.67}}
\bezier{256}(34.67,20.67)(38.67,2.33)(83.00,10.67)
\put(55.67,4.33){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\end{picture}

\vspace{-0.3cm}

Вилучаїмо стан 3 (як промўжний). Для цього стану вхўдними станами
ї 0, 4, 5, а вихўдними -- стани 4, 5.

\vspace{-1.5cm}

\unitlength=1.00mm
\linethickness{0.4pt}
\special{em:linewidth 0.4pt}
\begin{picture}(100.99,93.33)
\put(30.33,58.33){\circle{5.33}}
\put(30.33,58.33){\makebox(0,0)[cc]{{\tiny 0}}}
\put(33.00,58.33){\vector(3,-2){14.33}}
\put(50.67,48.33){\circle{5.33}}
\put(30.33,48.33){\circle{5.33}}
\put(33.00,48.33){\vector(1,0){14.33}}
\put(30.33,38.33){\circle{5.33}}
\put(33.00,38.33){\vector(3,2){14.67}}
\put(53.33,48.33){\vector(2,1){11.00}}
\put(67.33,55.33){\circle{5.33}}
\put(53.33,48.33){\vector(3,-1){11.00}}
\put(67.33,43.67){\circle{5.33}}
\put(40.33,56.00){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(38.00,50.00){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(40.33,40.67){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(58.67,53.33){\makebox(0,0)[cc]{{\tiny $b$}}}
\put(58.67,44.33){\makebox(0,0)[cc]{{\tiny $a$}}}
\put(10.00,15.00){\circle{5.33}}
\put(12.67,15.00){\vector(4,1){25.67}}
\put(41.33,22.00){\circle{5.33}}
\put(13.00,14.67){\vector(4,-1){25.33}}
\put(41.67,7.00){\circle{5.33}}
\put(10.00,15.00){\makebox(0,0)[cc]{{\tiny 0}}}
\put(23.67,20.67){\makebox(0,0)[cc]{{\tiny $a^{-1}b \vee ab$}}}
\put(23.67,8.67){\makebox(0,0)[cc]{{\tiny $b^{-1}a \vee a^2$}}}
\put(65.00,22.33){\circle{5.33}}
\put(67.67,22.33){\vector(1,0){27.33}}
\put(98.33,22.33){\circle{5.33}}
\put(62.67,23.33){\line(0,1){7.67}}
\put(62.67,31.00){\line(1,0){4.67}}
\put(67.33,31.00){\vector(0,-1){6.33}}
\put(73.00,28.00){\makebox(0,0)[cc]{{\tiny $ab$}}}
\put(82.00,24.33){\makebox(0,0)[cc]{{\tiny $a^2$}}}
\put(65.00,7.00){\circle{5.33}}
\put(67.67,7.00){\vector(1,0){27.33}}
\put(98.33,7.00){\circle{5.33}}
\put(81.67,8.67){\makebox(0,0)[cc]{{\tiny $ab$}}}
\put(62.67,8.00){\line(0,1){7.67}}
\put(62.67,15.67){\line(1,0){4.67}}
\put(67.33,15.67){\vector(0,-1){6.67}}
\put(72.00,12.67){\makebox(0,0)[cc]{{\tiny $a^2$}}}
\put(61.67,61.00){\vector(1,-1){3.67}}
\bezier{152}(62.00,60.67)(49.67,71.00)(30.33,61.00)
\put(30.33,38.33){\makebox(0,0)[cc]{{\tiny 5}}}
\put(67.33,43.67){\makebox(0,0)[cc]{{\tiny 5}}}
\put(65.00,7.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(41.67,7.00){\makebox(0,0)[cc]{{\tiny 5}}}
\put(98.33,22.33){\makebox(0,0)[cc]{{\tiny 5}}}
\put(71.33,48.67){\vector(-1,-2){1.67}}
\bezier{424}(71.00,48.33)(81.00,93.33)(30.33,61.00)
\put(63.67,71.00){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(48.67,63.33){\makebox(0,0)[cc]{{\tiny $b^{-1}a$}}}
\put(30.33,48.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(50.67,48.33){\makebox(0,0)[cc]{{\tiny 3}}}
\put(67.33,55.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(65.00,22.33){\makebox(0,0)[cc]{{\tiny 4}}}
\put(98.33,7.00){\makebox(0,0)[cc]{{\tiny 4}}}
\put(41.33,22.00){\makebox(0,0)[cc]{{\tiny 4}}}
\end{picture}

Пўсля вилучення стану 3 автомат редукуїться до такого вигляду:

\vspace{0.2cm}

\unitlength=1.10mm
\special{em:linewidth 0.4pt}
\linethickness{0.4pt}
\begin{picture}(126.67,63.66)(7,0)
\put(69.33,61.00){\circle{5.33}}
\put(69.33,61.00){\circle{4.00}}
\put(69.33,61.00){\makebox(0,0)[cc]{{\tiny 0}}}
\put(69.33,58.34){\vector(-3,-1){36.33}}
\put(30.00,44.34){\circle{6.00}}
\put(30.00,44.34){\circle{4.67}}
\put(30.00,44.34){\makebox(0,0)[cc]{{\tiny 2}}}
\put(44.00,55.34){\makebox(0,0)[cc]{{\tiny $a^{-2} \vee b^{-1}a^{-1}$}}}
\put(69.33,58.34){\vector(0,-1){12.00}}
\put(69.33,43.34){\circle{6.00}}
\put(69.33,43.34){\circle{4.67}}
\put(69.33,43.34){\makebox(0,0)[cc]{{\tiny 5}}}
\put(60.67,50.00){\makebox(0,0)[cc]{{\tiny $a^2 \vee b^{-1}a$}}}
\put(69.33,58.34){\vector(3,-1){36.00}}
\put(108.67,44.34){\circle{6.00}}
\put(108.67,44.34){\circle{4.67}}
\put(108.67,44.34){\makebox(0,0)[cc]{{\tiny 4}}}
\put(91.33,55.34){\makebox(0,0)[cc]{{\tiny $ab \vee a^{-1}b$}}}
\put(33.00,45.00){\vector(1,0){34.00}}
\put(66.67,41.67){\vector(-1,0){34.33}}
\put(71.67,45.00){\vector(1,0){34.33}}
\put(107.00,41.67){\vector(-1,0){34.67}}
\put(108.67,47.34){\line(0,1){6.33}}
\put(108.67,53.67){\line(1,0){18.00}}
\put(126.67,53.67){\line(0,-1){11.67}}
\put(126.67,42.00){\vector(-1,0){15.67}}
\put(30.00,47.34){\line(0,1){6.33}}
\put(30.00,53.67){\line(-1,0){19.67}}
\put(10.33,53.67){\line(0,-1){12.00}}
\put(10.33,41.67){\vector(1,0){18.33}}
\put(19.67,49.00){\makebox(0,0)[cc]{{\tiny $(a^{-2})^* \vee (b^{-1}a^{-1})^*$}}}
\put(50.67,46.67){\makebox(0,0)[cc]{{\tiny $ba^{-1}$}}}
\put(50.67,40.00){\makebox(0,0)[cc]{{\tiny $b^{-1}a^{-1}$}}}
\put(91.33,40.34){\makebox(0,0)[cc]{{\tiny $a^2$}}}
\put(91.33,47.00){\makebox(0,0)[cc]{{\tiny $ab$}}}
\put(117.67,49.34){\makebox(0,0)[cc]{{\tiny $(ab)^* \vee (a^{-1}b)^*$}}}
\put(104.00,38.00){\vector(3,2){4.00}}
%\bezier{328}(104.67,15.67)(70.00,-1.00)(31.33,18.67)
\put(32.67,38.00){\vector(-2,3){2.33}}
%\bezier{392}(32.33,15.67)(73.33,-13.00)(109.67,18.00)
\put(67.67,40.67){\line(0,-1){6.33}}
\put(67.67,34.33){\line(1,0){3.33}}
\put(71.00,34.33){\vector(0,1){6.00}}
\put(69.33,32.67){\makebox(0,0)[cc]{{\tiny $(a^2)^* \vee (b^{-1}a)^*$}}}
\bezier{336}(104.00,38.00)(65.67,18.67)(31.67,41.33)
\bezier{428}(32.67,37.67)(71.33,2.67)(109.67,41.33)
\put(69.00,26.00){\makebox(0,0)[cc]{{\tiny $a^{-1}b$}}}
\put(69.00,18.33){\makebox(0,0)[cc]{{\tiny $a^{-2}$}}}
\end{picture}

\vspace{-1.5cm}

З вигляду цього автомата очевидним чином випливаї множина твўрних
групи, слова яко∙ акцептуї даний автомат.  Цими  твўрними  будуть
слова мўнўмально∙  довжини,  якў  переводять автомат ўз стану 0 в
один ўз заключних станўв.  В даному випадку це будуть  слова  $e,
a^2, ab,   a^{-2},  b^{-1}a^{-1},  b^{-1}a,  a^{-1}b$.  Вилучаючи
$a^{-2}, b^{-1}a^{-1}, a^{-1}$ як оберненў до тих, що залишилися,
отримуїмо $P' = \{e,  a^2, ab, a^{-1}b\}$ як множину твўрних.
Якщо збудувати нўльсенўвський базис за цўїю множиною твўрних,  то
вўн матиме вигляд $P = \{a^2, ab\}$. $\spadesuit$

Пўдводить пўдсумок всьому сказаному в цьомў пўдроздўлў така
\begin{theorem}
Перетин скўнченного числа скўнченно породжуваних вўльних груп
ї скўнченно породжуваною вўльною групою. Складнўсть алгоритма
побудови нўльсенўвсько∙  системи  твўрних  для групи $H = G(P_1)
\cap G(P_2)$ пропорцўональна величинў $const N^5$, де $P_1, P_2$
-- нўльсенўвськў  системи твўрних, а $N = \max (L(P_1), L(P_2))$.
\end{theorem}

Таким чином,  якщо множини $ef(М,y)$ являють собою скўнченно
породжуванў пўдгрупи,  то задача про перетин маї розв'язок. Як
уже зазначалося, множини $ef(М,y)$ не завжди ї скўнченно породжуваними
групами ў в цьому випадку неясно як розв'язувати задачу про перетин.
В зв'язку з цим потрўбно обмежуватися розглядом не всўї∙  множини
$H(P)$,  а ∙∙ скўнченно породжувано∙ пўдгрупи $G_P(R)$.

\begin{theorem}
                      Функцўя ef монотонна.
\end{theorem}

    {\em Доведення}.  Нехай $P_1 = \{r_3^{-1}r_2r_3r_1\}, \ P_2 =
\{r_1, r_2\}$.   Ясно,   що   $P_2   =   P_2'$,   а    $P_1'    =
\{r_3^{-1}r_2r_3r_1, r_1^{-1}r_3^{-1}r_2^{-1}r_3\}$. Очевидно, що
$P_1 \subseteq H(P_2)$ ў $H(P_1) \subseteq H(P_2)$, оскўльки
$p = r_3^{-1}r_2r_3r_1 = (r_3^{-1}r_2r_3)r_1 \in H(P_2)$.

Але алгоритм ПЕРЕТИН не  зможе  знайти  того,  що  $P_1  \subseteq
H(P_2)$ ў побудуї пустий перетин (оскўльки $P_2$ взагалў не включаї
символўв $r_3$ ў $r_3^{-1}$). Отже, $H(P_1) \cap H(P_2) = \{e\}$ --
даї тривўальну пўдгрупу.

Розглянемо оператор  присвоювання  $y = (r_1 := r_1,  r_2 := r_2,
r_3 := r_3, r_4 := r_3^{-1}r_2r_3r_1$). Для цього оператора маїмо
\begin{center}
$ef(H(P_1') \cap    H(P_2'),y)    =    ef(\emptyset,     y)     =
\{r_4^{-1}r_3^{-1}r_2r_3r_1\}$
\end{center}
ў
\begin{center}
       $ef(H(P_1'),y) \cap       ef(H(P_2'),y)      =      \{r_4,
r_3^{-1}r_2r_3r_1\}$.
\end{center}
Очевидно, що
\begin{center}
     $ef(H(P_1') \cap    H(P_2'),y)    =    ef(H(P_1'),y)    \cap
ef(H(P_2'),y)$. $blacksquare$
\end{center}

Отже, в силу теорем 5.1.3  ў  3.3.9  алгоритм  МВА
будуї максимально  багату множину ўнварўантўв ў його завершення
стосовно до даного випадку випливаї з теореми 3.3.4.

Розглянемо деякў можливў шляхи пўдвищення породжуючо∙ здатностў
алгоритма побудови базиса перетину для пўдгруп.


\subsubsection{Пўдвищення породжуючо∙ здатностў алгоритма ПЕРЕТИН}
\ \  \  \  Зазначимо, що породжуючу здатнўсть алгоритма ПЕРЕТИН
можно пўдвищити,  якщо  замўсть  породжуючих  множин слўв $P_1$ ў
$P_2$ розглядати породжуючў множини $P_1'$ ў $P_2'$, поповненў
циклўчно нескорочуваними  циклўчними  перестановками всўх слўв ўз
$P_1$ ў $P_2$ вўдповўдно або ўншими словами тўї∙ж властивостў.
Розглянемо деякў можливў поповнення.

{\bf Циклўчне поповнення базисўв} $P_1$ ў $P_2$ полягаї в тому, що
цў множини поповнюються новими елементами, якў ї циклўчними
перестановками слўв, якў складають множини $P_1$ ў $P_2$.

Вўдносно $H(P_1')$ ў $H(P_2')$, де $P_1', P_2'$ -- циклўчно поповненў
базиси, маї мўсце таке твердження.
\begin{lemma}
    H(P) = H(P'), де $P = P_1$ або $P = P_2$.
\end{lemma}

{\em Доведення} випливаї з того,  що ўз $P \subseteq P'$ випливаї
$H(P) \subseteq H(P')$. З другого боку, оскўльки $H(P)$ нормальна
пўдгрупа групи $T_D(R)$,  то якщо $p \in H(P)$, то ў довўльна його
циклўчна перестановка $p'$  теж ї елементом $H(P)$.  Дўйсно,
нехай $p = x_ip_1x_j \ (x_i, x_j \in R \cup R^{-1}$) -- циклўчно
нескорочуване слово ўз $P$.  Тодў слово $x_i^{-1}(x_ip_1x_j)x_i =
p_1x_jx_i$ ї словом ўз $H(P)$. Отже, $P' \subseteq H(P)$ ў $H(P')
\subseteq H(P)$. Таким чином, $H(P) = H(P')$. $\blacksquare$

{\bf Приклад} циклўчного поповнення базисўв. Нехай $R \cup R^{-1}
= \{a,  b,  c,  a^{-1},  b^{-1},  c^{-1}\}$, a $P_1 = \{abc^{-1},
ab^{-1}c^{-1}, bca^{-2}\}$ ў $P_2 =\{b^2,  c^{-1}aca^{-2}\}$.
Якщо обчислити базис перетину груп $G(P_1) \cap G(P_2)$,  то вўн буде
тривўальним, тобто  $G(P_1)  \cap G(P_2) = \{e\}$ ў,  отже,  $P =
\{e\}$. Виконаїмо циклўчне  поповнення  базисўв  $P_1$  ў  $P_2$:
$P_1' =    \{abc^{-1},    c^{-1}ab,    bc^{-1}a,   ab^{-1}c^{-1},
c^{-1}ab^{-1}, b^{-1}c^{-1}a,      bca^{-2},      a^{-1}bca^{-1},
a^{-1}a^{-1}bc, ca^{-1}a^{-1}b\},  \ P2' = \{b^2, c^{-1}aca^{-2},
a^{-1}c^{-1}aca^{-1}, a^{-2}c^{-1}ac,             ca^{-2}c^{-1}a,
aca^{-2}c^{-1}\}$.

Базис перетину $G(P_1) \cap G(P_2)$ для поповнених базисўв ўаї вже
нетривўальний  перетин ў включаї елемент $c^{-1}aca^{-2}$ ў всў його
циклўчнў перестановки. $\spadesuit$


{\bf Спряжене поповнення базисўв} $P_1$ ў $P_2$ полягаї в тому,
що циклўчно поповненў базиси $P_1$ ў $P_2$  поповнюються словами,
якў ї спряженими, тобто коли вўдомо, що $xpx^{-1} \in H$,
то ў $p \in H$, оскўльки $H$ -- нормальний дўльник.

Спряжене поповнення базисўв можна обчислити за допомогою модифўкованого
алгоритму Нўльсена. Ця модифўкацўя полягаї в тому, що порўвняння
довжин слўв початкового ў отриманого в результатў виконання
нўльсенўвського перетворення, вўдбуваїться тўльки пўсля того, як  в
отриманому словў вилучена спряженўсть (тобто, пўсля
того, як це слово буде перетворене до циклўчно нескорочуваного).
Алгоритм закўнчуї свою роботу в тому випадку,  коли нўяке
перетворення не зменшуї довжину слўв  ў  всў  слова  циклўчно
приведенў.

{\bf Продовження попереднього приклада}. Якщо взяти елементи
$abc^{-1}$ ў $(ab^{-1}c^{-1})^{-1}$ ўз $P_1$ ў перемножити ∙х,
то отримуїмо $(abc^{-1})(ab^{-1}c^{-1})^{-1} = ab^2a^{-1}$. Отже,
елемент $b^2 \in H(P_1)$.  В результатў в перетин попадаї елемент
$b^2$ ў, отже, $H(P_1) = H(P_2)$. $\spadesuit$

{\bf Комутаторне  поповнення базиса} $P$ полягаї в тому, що
пўсля обчислення перетину пўдгруп з поповненими базисами,
множина $P$ поповнюїться комутаторами вигляду $p^{-1}q^{-1}pq,  \
p \in P_1,  \ q \in P_2,  \ i = 1,\ldots,  m, \ j = 1,\ldots, k.$
виконуючи далў побудову нўльсенўвських твўрних для $P$, отримуїмо
остаточну множину твўрних для $H = H(P_1) \cup H(P_2)$. Варто
зауважити, що коли в цьому ї необхўднўсть,  то поповнювати можна як
елементами вигляду $p^{-n}q^{-1}p^nq$, так ў елементами вигляду
$p^{-1}q^{-n}pq^n$ ў $p^{-n}q^{-n}p^nq^n$, де $n$ -- довўльне
скўнченне натуральне число.

Розглянутў апроксимацў∙ множин  спўввўдношень,  обчислюваних  при
розв'язаннў задачў про  спўввўдношення, ї зростаючими, тобто такими,
якў збўльшують породжуючу силу описаних алгоритмўв генерацў∙
ўнварўантних спўввўдношень.  В силу теореми \ref{3.3.9}
результат роботи алгоритма МВА при довўльнўй ўз цих апроксимацўй не
залежить вўд способу обходу станўв $U-Y$-програми, але будуї
меншу множину ўнварўантўв в даному станў $a$, нўж множина
\begin{center}
         $N_a =  \bigcap\limits_{l=l(a_0,a)} ef(N_0,y_l),$
\end{center}
де $l$ пробўгаї всў шляхи, що ведуть ўз $a_0$ в $a$.

Пўдводячи пўдсумок,  сформулюїмо твердження, яке випливаї з
вищенаведених побудов, лем ў теорем.
\begin{theorem}
Для довўльно∙  $U-Y$-програми,  алгебра даних яко∙ вўльна група з
умовою скўнченно∙ породжуваностў для пўдгруп, алгоритм МВА закўнчуї
свою роботу пўсля скўнченного числа крокўв.  Результат роботи
алгоритма МВА не залежить вўд  способу  обходу  станўв  програми.
\end{theorem}





\begin{thebibliography}{999}

{\scriptsize

\bibitem{abr}{\em Абрамов С.А.}
\newblock Элементы анализа программ.
\newblock {\em - М.: Наука. -1988. - 129 стр.}

\bibitem{ahu} {\em Ахо А., Хопкрофт Дж., Ульман Дж.}
\newblock Построение и анализ вычислительных алгоритмов.
\newblock {\em -М.: Мир. -1979. - 535 с.}

\bibitem{birb} {\em Биркгоф Г., Барти Т.}
\newblock Современная прикладная алгебра.
\newblock {\em -M.: Мир. -1976. -400 c.}

\bibitem{vas} {\em  Васильев  Ю.Л.,  Ветухновский Ф.Я.,  Глаголев В.В. и др.}
\newblock Дискретная математика и математические вопросы кибернетики (т.1).
\newblock {\em М.: Наука. - 1974. - 311 с.}

\bibitem{virt} {\em Вирт Н.}
\newblock Систематическое программирование.
\newblock {\em -М.: Мир. -1978. 183 с.}

\bibitem{gl1} {\em Глушков В.М.}
\newblock Введение в  кибернетику.
\newblock {\em -Киев:  Изд-во  АН УССР. -1964. - 324 c.}

\bibitem{glu} {\em Глушков В.М., Цейтлин Г.Е., Ющенко Е.Л.}
\newblock  Алгебра, языки, программирование.
\newblock {\em -К.: Наук. думка. -1985. - 327 с.}

\bibitem{glg} {\em Глушков В. М., Летичевский А. А., Годлевский А. Б.}
\newblock Методы синтеза дискретных моделей биологических систем.
\newblock -- К.: Вища школа, 1983. -- 262 с.

\bibitem{74} Летичевский А.А., Годлевский А.Б., Кривой С.Л.
\newblock Об эффективном алгоритме  построения  базиса  подгруппы
          свободной группы.
\newblock {\em ж. Кибернетика. -1981. - N3. - C.107-116}.


\bibitem{75} Летичевский А.А.,  Кривой С.Л.
\newblock О реализации  алгоритма  Нильсена  в  системе  алгебраического
           программирования АПС-1.
\newblock {\em Кибернетика. - 1994. - N 5 .- C. 126--132}.

\bibitem{gkr} {\em Годлевский А. Б., Кривой С. Л.}
\newblock Трансформационный синтез эффективных алгоритмов
с учетом дополнительных спецификаций
\newblock Кибернетика. -- 1986. -- $\textnumero$ 6. -- C. 34--43.

\bibitem{gkr1} {\em Годлевский А. Б., Кривой С. Л.}
\newblock О проектировании эффективных алгоритмов приведения
автоматов для некоторых отношений эквивалентности
\newblock Кибернетика и сист. анализ. -- 1989. -- $\textnumero$
6. -- C. 54--61.

\bibitem{kriv} {\em  Годлевский  А.Б.,  Капитонова  Ю.В.,  Кривой С.Л., Летичевский А.А.}
\newblock Итеративные методы анализа программ.
\newblock  ж. Кибернетика. -- 1989. -- N2. -- C. 9--19.

\bibitem{kriv1} {\em Годлевский  А.Б.,  Капитонова Ю.В.,  Кривой С.Л., Летичевский А.А.}
\newblock Итеративные методы анализа программ.  Равенства и неравенства.
\newblock {\em ж. Кибернетика. -- 1990. -- N3. -- C. 1--9.}

\bibitem{kriv2} {\em Годлевский А.Б., Кривой  С.Л.}
\newblock Об оптимизации спроектированных методами ``сверху-вниз'' программ.
\newblock {\em  Модели  и  системы обработки информации.- К.: Вища школа.
     -1984. -вып.3.- С. 25-33.}

\bibitem{kriv3} {\em Годлевский А.Б.,  Кривой С.Л.}
\newblock  О  методике  ирансформационного синтеза алгоритмов и программ.
\newblock {\em Смешанные вычисления и преобразование программ. (Сборник
               научных трудов). Новосибирск. -1991. -C. 53-58.}

\bibitem{kriv4} {\em Годлевский А.Б., Кривой С.Л.}
\newblock Редукция программ с учетом дополнительных спецификаций.
\newblock {\em ж. Кибернетика. - 1991.- N 5. - C. 57--67.}

\bibitem{kriv5} {\em Годлевский А.Б., Кривой С.Л.}
\newblock  Трансформационный синтез эффективных алгоритмов с учетом
           дополнительных спецификаций.
\newblock  {\em ж.  Кибернетика.-1986. - N6.- C. 37--43.}

\bibitem{kriv6} {\em Годлевский А.Б.,  Кривой С.Л.}
\newblock О проектировании эффективных алгоритмов приведения
          автоматов для некоторых отношений  эквивалентности.
\newblock {\em ж. Кибернетика. -1989. -N6. -C. 54--61.}

\bibitem{kal} {\em Калужнин Л.А.}
\newblock Введение в общую алгебру.
\newblock {\em -M.: Наука. -1973. -447 c.}

\bibitem{kri3} {\em Кривий С. Л.}
\newblock Дискретна математика: вибранў питання.
\newblock {\em Ки∙в:  Видавничий дўм  ``Київо-Могилянська
                      академўя''. - 2007. - 570 с.}

\bibitem{mal} {\em Мальцев А.И.}
\newblock  Алгебраические системы.
\newblock {\em -М.: Наука. - 1970. - 370 с.}

\bibitem{mal1} {\em Мальцев А.И.}
\newblock  Алгоритмы и рекурсивные функции.
\newblock {\em -М.: Наука. - 1986. - 367 с.}

\bibitem{mar} {\em Марков А.А., Нагорный Н.М.}
\newblock Теория алгорифмов.
\newblock {\em М: ФАЗИСТ. -1996. - 448 с.}

\bibitem{men} {\em Мендельсон Э.}
\newblock Введение в математическую логику.
\newblock {\em -М.: Мир. - 1988. - 320 с.}

\bibitem{skor} {\em Скорняков Л.А.}
\newblock Элементы теории структур
\newblock {\em -M.: Наука. -1982. -158 c.}

\bibitem{spr}
Справочная книга по математической  логике.  Часть  III.
Теория рекурсии.
\newblock -- М.: Наука, 1982. -- 359 с.

\bibitem{stol} {\em Столл Р.}
\newblock Множества, логика, аксиоматические теории.
\newblock {\em -M.: Просвещение. -1968. - 230 c.}

\bibitem{shr}  {\em Схрейвер А.}
\newblock Теория линейного и целочисленного программирования, т. 1, 2.
\newblock -- М.: Мир, 1991. -- 742 с.

\bibitem{uil} {\em Уилсон Р.}
\newblock Введение в теорию графов.
\newblock {\em -М.: Мир. -1977. -205 с.}

\bibitem{che} {\em Чень Ч., Ли Р.}
\newblock Математическая логика и автоматическое доказательство теорем.
\newblock {\em -М.: Наука. -1983. - 256 с.}

\bibitem{b-ari} {\em Ben-Ari M.}
\newblock Mathematical Logic for Computer Science.
\newblock {\em Prentice Hall International (UK) Ltd. -1993. -305 p.}

\bibitem{bry} {\em Bryant R. E.}
\newblock Symbolic  Boolean  Manipulation  with  Ordered   Binary
          Decision Diagrams.
\newblock --  School  of   Computer   Science,   Carnegi   Mellon
University. -- Pittsburg. - 1992 (june). -- 34 p.

\bibitem{bry1} {\em Burch J. R., Clarke E. M., McMillan K.}
\newblock Symbolic model checking: $10^{20}$ states and beyond.
\newblock -- Fifth Annual IEEE Symposium on Logic in Comp. Sci.
(Philadelphia, June). IEEE, New York. -- 1990. -- P. 428--439.

\bibitem{burch} {\em Burch J. R., Clarke E. M., Dill D. L., McMillan K.}
\newblock Sequential circuit verification using symbolic model checking.
\newblock -- Proceedings of the 27-th  ACM/IEEE  Design Automation
Conference (Orlando, June). ACM, New York. -- 1990. -- P. 46--51.

\bibitem{clar} {\em Clarke E. M., Emerson E. A., Sistla A. P.}
\newblock Automaric verification of finite-state concurent systems using
          temporal logic specifications
\newblock ACM Transactions on Programming
          Languages.  -- 1986. -- $\textnumero$ 2, (April). --
          P. 214--263.

\bibitem{cod} {\em Codd E.F.}
\newblock A relation model for large shared data banks.
\newblock {\em -CACM. -1970.-v.13.-N 6. -P. 377-387}

\bibitem{jons} {\em Johnson D.S.}
\newblock A Catalogue of Complexity Classes
\newblock {\em -in J. van Leeuwen., ed. ``Handbook of Theoretical
           Computer Science''.  vol.  A.  -1990 : Elsevier. - PP.
67-161.}

\bibitem{pap} {\em Papadimitriou C.H.}
\newblock Computational complexity.
\newblock {\em - Addison-Wesley. -1994. - 532 p.}

\bibitem{ged} {\em Гери М. Р., Джонсон Д.С.}
\newblock Вычислительные машины и трудновычислимые задачи.
\newblock {\em - М.: Мир. - 1982. - 416 с.}

\bibitem{rob} {\em Robinson J. A.}
\newblock A  mashine  oriented  logic  based  on  the  rtsolution
principle
\newblock JACM. -- 1965. -- 12. -- $\textnumero$ 1. -- P. 23--41.

\bibitem{fl1} {\em Fisher M.J., Ladner R.E.}
\newblock Propositional Modal Logic of Programs.
\newblock {\em in Proc. 9-th ACM Ann. Symposium on Theory of Computing.
           1977. -PP 286-294.}

\bibitem{fl2} {\em Fisher M.J., Ladner R.E.}
\newblock Propositional Dynamic Logic of regular programs.
\newblock {\em J. Comp. System Sci. -1979. -v.18. -N2. -PP 194 -- 211}

\bibitem{kil} {\em Kildall G.A.}
\newblock A unified approach to program  optimization.
\newblock {\em Conf.  Rec.  of ACM Symp.  on Prince. of Program Languages
    Boston, Massachusetts. - Oktober 1-3. -1973.-P. 194--206.}

\bibitem{hoar} {\em Hoare C.A.R.}
\newblock An  axiomatic  basis of computer programming.
\newblock {\em CACM. -1969. -v.12. -P. 576 -- 580.}

\bibitem{how} {\em Howson A.V.}
\newblock On the intersection of  finitely  generated  free groups.
\newblock {\em Journ. London Math. Soc. -1954.-N29.-P. 428--434.}

\bibitem{kamu} {\em Kam J.B.,  Ullman D.J.}
\newblock Monotone  data  flow  analysis  frame works.
\newblock {\em Acta Inform. -1978. -N3. -P. 305--318.}

\bibitem{gold} {\em Goldblatt R.}
\newblock Logics of Time and Computation.
\newblock Lecture Notes.  -- $\textnumero$ 7.  Center  for  the  Study  of
Language and Information. -- 1987.

\bibitem{pet} {\em Peterson G. L.}
\newblock Myths about the mutual exclusion problem.
\newblock {\em Information Processing Letters.  -- 1981.  -- v. 12.
-- $\textnumero$ 3. -- P. 115--116.}

\bibitem{122} {\em Hopcroft J.E.,  Ullman J.D.}
\newblock An n*log n algorithm to  detected reducible  graphs.
\newblock {\em In Proc.  6-th Annual Princeton Conference on
    Information Sciences and Systems.-1972.-P.119-122.}

\bibitem{123} {\em Ullman J.D.}
\newblock Fast algorithms for elimination of common subexpressions.
\newblock {\em Acta Inform. --1973. -- $\textnumero$ 2. -- P. 191--213.}

}
\end{thebibliography}
\end{document}
